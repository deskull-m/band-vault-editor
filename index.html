<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vault Editor</title>
    <link href="editor.css" rel="stylesheet">

    <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/konva/8.3.9/konva.min.js"></script>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet"
        integrity="sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.0/font/bootstrap-icons.css">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.bundle.min.js"
        integrity="sha384-MrcW6ZMFYlzcLA8Nl+NtUVF0sA7MsXsP1UyJoMp4YLEuNSfAP+JcXn/tWtIaxVXM"
        crossorigin="anonymous"></script>
</head>

<body>
    <div id="toggle"></div>
    <div id="version"></div>

    <div id="editor">
        <h2></h2>
        <div><span class="param">部屋ID:</span><input type="number" class="int" id="vault-id" name="vault-id" min="0"
                value="0"></div>
        <div><span class="param">種別ID:</span><input type="number" class="int" id="vault-type" name="vault-type" min="0"
                value="18"></div>
        <div><span class="param">幅:</span><input type="number" class="int" id="vault-width" name="vault-width" min="3"
                max="240" value="14"></div>
        <div><span class="param">高さ:</span><input type="number" class="int" id="vault-height" name="vault-height"
                min="3" max="240" value="14"></div>
        <div><span class="param">名前:</span><input type="text" class="int" id="vault-name" name="vault-name" value="">
        </div>
        <select id="grid_type">
            <option value=".">. - Floor</option>
            <option value=" ">SPACE - None</option>
            <option value="%">% - outside of the vault, where corridors may be connected</option>
            <option value="#"># - granite</option>
            <option value="$">$ - glass wall</option>
            <option value="X">X - impenetrable rock</option>
            <option value="Y">Y - impenetrable glass wall</option>
            <option value="*">* - treasure or trap</option>
            <option value="+">+ - secret door</option>
            <option value="-">- - secret glass door</option>
            <option value="'">' - curtain</option>
            <option value="^">^ - trap</option>
            <option value="&">& - monster up to 5 levels out of depth (OOD)</option>
            <option value="@">@ - monster up to 11 levels OOD</option>
            <option value="9">9 - monster up to 9 levels OOD and treasure up to 7 levels OOD</option>
            <option value="8">8 - monster up to 40 levels OOD and treasure up to 20 levels OOD</option>
            <option value=",">, - monster up to 3 levels OOD and/or treasure up to 7 levels OOD</option>
            <option value=":">: - tree</option>
            <option value="[">[ - treasure</option>
            <option value="~">~ - shallow water</option>
            <option value="=">= - deep water</option>
            <option value="v">v - shallow lava</option>
            <option value="w">w - deep lava</option>
            <option value="f">f - shallow acid puddle</option>
            <option value="F">F - deep acid puddle</option>
            <option value="g">g - shallow poisonous puddle</option>
            <option value="G">G - deep poisonous puddle</option>
            <option value="h">h - cold zone</option>
            <option value="H">H - heavy cold zone</option>
            <option value="i">i - electrical zone</option>
            <option value="I">I - heavy electrical zone</option>
        </select>
        <div id="slide_keys">
        </div>
        <!-- Bootstrap Modal for Symbol Dialog -->
        <div class="modal fade" id="symbolModal" tabindex="-1" aria-labelledby="symbolModalLabel" aria-hidden="true">
            <div class="modal-dialog modal-lg">
                <div class="modal-content">
                    <div class="modal-header">
                        <h5 class="modal-title" id="symbolModalLabel">新規地形定義</h5>
                        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                    </div>
                    <div class="modal-body">
                        <div class="mb-3">
                            <label for="symbolInput" class="form-label">地形シンボル (1文字):</label>
                            <input type="text" class="form-control" id="symbolInput" maxlength="1" style="width: 80px;">
                        </div>
                        <div class="mb-3">
                            <label for="actualTerrain" class="form-label">実際の地形:</label>
                            <div class="input-group mb-2">
                                <input type="text" class="form-control" id="actualTerrainFilter" placeholder="地形名で検索..."
                                    onkeyup="filterActualTerrain()">
                                <button class="btn btn-outline-secondary" type="button"
                                    onclick="clearActualTerrainFilter()">クリア</button>
                            </div>
                            <select class="form-select" id="actualTerrain" size="5">
                                <option value="">選択してください</option>
                            </select>
                        </div>
                        <div class="mb-3">
                            <label for="visualTerrain" class="form-label">見た目の地形:</label>
                            <div class="input-group mb-2">
                                <input type="text" class="form-control" id="visualTerrainFilter" placeholder="地形名で検索..."
                                    onkeyup="filterVisualTerrain()">
                                <button class="btn btn-outline-secondary" type="button"
                                    onclick="clearVisualTerrainFilter()">クリア</button>
                            </div>
                            <select class="form-select" id="visualTerrain" size="5">
                                <option value="">選択してください</option>
                            </select>
                        </div>
                        <div class="mb-3">
                            <label for="monsterSelect" class="form-label">配置モンスター (オプション):</label>
                            <div class="input-group mb-2">
                                <input type="text" class="form-control" id="monsterFilter" placeholder="モンスター名で検索..."
                                    onkeyup="filterMonsters()">
                                <button class="btn btn-outline-secondary" type="button"
                                    onclick="clearMonsterFilter()">クリア</button>
                            </div>
                            <select class="form-select" id="monsterSelect" size="5">
                                <option value="">なし</option>
                            </select>
                        </div>
                    </div>
                    <div class="modal-footer">
                        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">キャンセル</button>
                        <button type="button" class="btn btn-primary" onclick="defineCustomTerrain()">定義</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Bootstrap Modal for Delete Dialog -->
        <div class="modal fade" id="deleteModal" tabindex="-1" aria-labelledby="deleteModalLabel" aria-hidden="true">
            <div class="modal-dialog">
                <div class="modal-content">
                    <div class="modal-header">
                        <h5 class="modal-title" id="deleteModalLabel">カスタム地形削除</h5>
                        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                    </div>
                    <div class="modal-body">
                        <div class="mb-3">
                            <label for="deleteTerrainSelect" class="form-label">削除する地形を選択:</label>
                            <select class="form-select" id="deleteTerrainSelect" size="8">
                            </select>
                        </div>
                        <div class="alert alert-warning" role="alert">
                            <i class="bi bi-exclamation-triangle"></i>
                            選択した地形は完全に削除されます。この操作は取り消せません。
                        </div>
                    </div>
                    <div class="modal-footer">
                        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">キャンセル</button>
                        <button type="button" class="btn btn-danger" onclick="deleteCustomTerrain()">削除</button>
                    </div>
                </div>
            </div>
        </div>
        <!-- 古いsymbolDialogは削除 -->
        <button onclick="openDialog()" class="btn btn-warning">馬鹿馬鹿用独自地形定義</button>
        <button onclick="openDeleteDialog()" class="btn btn-danger">カスタム地形削除</button>
        <div class="btn-group me-2" role="group" aria-label="アンドゥ/リドゥ">
            <button onclick="undo()" class="btn btn-outline-secondary" title="元に戻す (Ctrl+Z)">
                <i class="bi bi-arrow-counterclockwise"></i> アンドゥ
            </button>
            <button onclick="redo()" class="btn btn-outline-secondary" title="やり直し (Ctrl+Y)">
                <i class="bi bi-arrow-clockwise"></i> リドゥ
            </button>
        </div>
        <div class="me-2">
            <div class="form-check form-check-inline">
                <input class="form-check-input" type="radio" name="drawingMode" id="normalMode" value="normal" checked
                    onchange="setDrawingMode()">
                <label class="form-check-label text-white" for="normalMode" title="通常の単一セル描画モード (Dキー)">
                    <i class="bi bi-pencil"></i> 通常描画
                </label>
            </div>
            <div class="form-check form-check-inline">
                <input class="form-check-input" type="radio" name="drawingMode" id="floodFillMode" value="floodFill"
                    onchange="setDrawingMode()">
                <label class="form-check-label text-white" for="floodFillMode" title="同じ地形の連続領域を一括で塗りつぶし (Fキー)">
                    <i class="bi bi-paint-bucket"></i> 塗りつぶし
                </label>
            </div>
            <div class="form-check form-check-inline">
                <input class="form-check-input" type="radio" name="drawingMode" id="rectangleMode" value="rectangle"
                    onchange="setDrawingMode()">
                <label class="form-check-label text-white" for="rectangleMode" title="矩形の枠線を描画 (Rキー)">
                    <i class="bi bi-square"></i> 矩形
                </label>
            </div>
            <div class="form-check form-check-inline">
                <input class="form-check-input" type="radio" name="drawingMode" id="filledRectangleMode"
                    value="filledRectangle" onchange="setDrawingMode()">
                <label class="form-check-label text-white" for="filledRectangleMode" title="矩形を塗りつぶして描画 (Shift+Rキー)">
                    <i class="bi bi-square-fill"></i> 塗りつぶし矩形
                </label>
            </div>
        </div>
        <div id="change_tile_size">
            <label for="tile_size" style="color:white;">タイルサイズ:</label>
            <input type="number" id="tile_size" value="24" min="1" max="100" step="1" onchange="updateTileSize()">
        </div>
    </div>
    <div id="mappings">
        <div id="tiles"></div>
        <div id="parse-error"></div>
        <div id="texts">

            <button id="copy" onclick="copyToClipboard()">コピー</button>

            <script>
                function copyToClipboard() {
                    var copyText = document.getElementById("v_info");

                    copyText.select();
                    copyText.setSelectionRange(0, 99999);
                    document.execCommand("copy");
                }
            </script>


            <textarea id="v_info"></textarea>
        </div>
    </div>


    <script>
        const VOID_TILE_COLOR = '#202020';
        const NORMAL_TILE_COLOR = '#000000';
        var touchmode = 'ontouchend' in document;

        // 地形定義データ
        let terrainDefinitions = [];
        let monsterDefinitions = []; // モンスター定義データ
        let customTerrains = {}; // カスタム地形の保存用

        // アンドゥ/リドゥ用の状態管理
        let undoStack = [];
        let redoStack = [];
        const MAX_UNDO_STEPS = 50; // 最大アンドゥ回数

        function update_texts() {
            let texts = document.getElementById('v_info');
            texts.value = `N:${mapID}:${mapName}\r\n`;
            texts.value += `X:${mapType}:8:${mapHeight}:${mapWidth}\r\n`;

            // カスタム地形定義を出力
            for (let symbol in customTerrains) {
                const terrain = customTerrains[symbol];
                let line = `F:${symbol}:${terrain.actual}:${terrain.visual}`;

                // モンスターが設定されている場合は:MONSTER_IDを追加
                if (terrain.monster) {
                    line += `:MONSTER_${terrain.monster}`;
                }

                texts.value += line + '\r\n';
            }

            for (let j = 0; j < mapHeight; j++) {
                texts.value += 'D:';
                for (let i = 0; i < mapWidth; i++) {
                    texts.value += grid[i][j];
                }
                texts.value += '\r\n';
            }
        }

        // 現在の状態を保存する関数
        function saveState() {
            const state = {
                grid: grid.map(row => [...row]), // ディープコピー
                mapWidth: mapWidth,
                mapHeight: mapHeight,
                mapName: mapName,
                mapID: mapID,
                mapType: mapType,
                customTerrains: JSON.parse(JSON.stringify(customTerrains)) // ディープコピー
            };

            undoStack.push(state);

            // スタックサイズを制限
            if (undoStack.length > MAX_UNDO_STEPS) {
                undoStack.shift();
            }

            // 新しい操作が行われたのでリドゥスタックをクリア
            redoStack = [];
        }

        // 状態を復元する関数
        function restoreState(state) {
            grid = state.grid.map(row => [...row]); // ディープコピー
            mapWidth = state.mapWidth;
            mapHeight = state.mapHeight;
            mapName = state.mapName;
            mapID = state.mapID;
            mapType = state.mapType;
            customTerrains = JSON.parse(JSON.stringify(state.customTerrains)); // ディープコピー

            // UI要素を更新
            document.getElementById('vault-width').value = mapWidth;
            document.getElementById('vault-height').value = mapHeight;
            document.getElementById('vault-name').value = mapName;
            document.getElementById('vault-id').value = mapID;
            document.getElementById('vault-type').value = mapType;

            // カスタム地形のセレクトボックスを再構築
            rebuildCustomTerrainOptions();

            // グリッドとテキストを更新
            drawGrid();
            update_texts();
        }

        // カスタム地形のセレクトボックスを再構築する関数
        function rebuildCustomTerrainOptions() {
            const gridTypeSelect = document.getElementById('grid_type');

            // 既存のカスタム地形オプションを削除
            const options = Array.from(gridTypeSelect.options);
            options.forEach(option => {
                // デフォルトの地形以外（カスタム地形）を削除
                if (!isDefaultTerrain(option.value)) {
                    gridTypeSelect.removeChild(option);
                }
            });

            // カスタム地形を再追加
            for (let symbol in customTerrains) {
                addSymbolToMainSelect(symbol);
            }
        }

        // デフォルト地形かどうかを判定する関数
        function isDefaultTerrain(symbol) {
            const defaultSymbols = ['.', ' ', '%', '#', '$', 'X', 'Y', '*', '+', '-', "'", '^', '&', '@', '9', '8', ',', ':', '[', '~', '=', 'v', 'w', 'f', 'F', 'g', 'G', 'h', 'H', 'i', 'I'];
            return defaultSymbols.includes(symbol);
        }

        // アンドゥ機能
        function undo() {
            if (undoStack.length === 0) {
                showToast('アンドゥできる操作がありません', 'info');
                return;
            }

            // 現在の状態をリドゥスタックに保存
            const currentState = {
                grid: grid.map(row => [...row]),
                mapWidth: mapWidth,
                mapHeight: mapHeight,
                mapName: mapName,
                mapID: mapID,
                mapType: mapType,
                customTerrains: JSON.parse(JSON.stringify(customTerrains))
            };
            redoStack.push(currentState);

            // 前の状態を復元
            const previousState = undoStack.pop();
            restoreState(previousState);

            showToast('操作を元に戻しました', 'success');
        }

        // リドゥ機能
        function redo() {
            if (redoStack.length === 0) {
                showToast('リドゥできる操作がありません', 'info');
                return;
            }

            // 現在の状態をアンドゥスタックに保存
            const currentState = {
                grid: grid.map(row => [...row]),
                mapWidth: mapWidth,
                mapHeight: mapHeight,
                mapName: mapName,
                mapID: mapID,
                mapType: mapType,
                customTerrains: JSON.parse(JSON.stringify(customTerrains))
            };
            undoStack.push(currentState);

            // 次の状態を復元
            const nextState = redoStack.pop();
            restoreState(nextState);

            showToast('操作をやり直しました', 'success');
        }

        // フラッドフィル（塗りつぶし）機能
        function floodFill(startX, startY, newTerrain) {
            const originalTerrain = grid[startX][startY];

            // 同じ地形の場合は何もしない
            if (originalTerrain === newTerrain) {
                return false;
            }

            // 状態を保存
            saveState();

            // BFS（幅優先探索）を使用してフラッドフィル
            const queue = [[startX, startY]];
            const visited = Array.from({ length: mapWidth }, () => Array(mapHeight).fill(false));

            while (queue.length > 0) {
                const [x, y] = queue.shift();

                // 範囲外または既に訪問済みの場合はスキップ
                if (x < 0 || x >= mapWidth || y < 0 || y >= mapHeight || visited[x][y]) {
                    continue;
                }

                // 異なる地形の場合はスキップ
                if (grid[x][y] !== originalTerrain) {
                    continue;
                }

                // 地形を変更し、訪問済みにマーク
                grid[x][y] = newTerrain;
                visited[x][y] = true;

                // 隣接する4方向を探索キューに追加
                queue.push([x + 1, y]);
                queue.push([x - 1, y]);
                queue.push([x, y + 1]);
                queue.push([x, y - 1]);
            }

            // グリッドとテキストを更新
            drawGrid();
            update_texts();

            return true;
        }

        // フラッドフィルモードの状態管理
        let isFloodFillMode = false;
        let isRectangleMode = false;
        let isFilledRectangleMode = false;

        // 矩形描画用の変数
        let isDrawingRectangle = false;
        let rectangleStartX = -1;
        let rectangleStartY = -1;
        let rectangleEndX = -1;
        let rectangleEndY = -1;
        let previewRectangle = null;

        // Konvaのグローバル変数
        let globalStage = null;
        let globalLayer = null;

        // 描画モードの設定（ラジオボタン用）
        function setDrawingMode() {
            const normalMode = document.getElementById('normalMode');
            const floodFillMode = document.getElementById('floodFillMode');
            const rectangleMode = document.getElementById('rectangleMode');
            const filledRectangleMode = document.getElementById('filledRectangleMode');

            // プレビューをクリア
            clearPreview();

            // 矩形描画状態をリセット
            isDrawingRectangle = false;
            rectangleStartX = -1;
            rectangleStartY = -1;
            rectangleEndX = -1;
            rectangleEndY = -1;

            // 全てのモードをリセット
            isFloodFillMode = false;
            isRectangleMode = false;
            isFilledRectangleMode = false;

            if (normalMode.checked) {
                showToast('通常描画モードに切り替えました', 'info');
            } else if (floodFillMode.checked) {
                isFloodFillMode = true;
                showToast('塗りつぶしモードに切り替えました: 地形をクリックして塗りつぶしてください', 'info');
            } else if (rectangleMode.checked) {
                isRectangleMode = true;
                showToast('矩形描画モードに切り替えました: ドラッグして矩形の枠線を描画してください', 'info');
            } else if (filledRectangleMode.checked) {
                isFilledRectangleMode = true;
                showToast('塗りつぶし矩形モードに切り替えました: ドラッグして矩形を塗りつぶしてください', 'info');
            }
        }

        // 旧関数（後方互換性のため残す）
        function toggleFloodFillMode() {
            const normalMode = document.getElementById('normalMode');
            const floodFillMode = document.getElementById('floodFillMode');

            if (isFloodFillMode) {
                normalMode.checked = true;
            } else {
                floodFillMode.checked = true;
            }
            setDrawingMode();
        } let mouseDown = false
        let currentTerrain = ".";

        if (touchmode) {
            document.body.ontouchstart = function () {
                mouseDown = true;
            }
            document.body.ontouchend = function () {
                mouseDown = false;
            }
        }
        else {
            document.body.onmousedown = function () {
                mouseDown = true;
            }
            document.body.onmouseup = function () {
                mouseDown = false;
            }
        }


        document.getElementById('grid_type').onchange = function () {
            currentTerrain = this.value;
        }

        // 矩形描画関数
        function drawRectangle() {
            if (rectangleStartX === null || rectangleStartY === null) return;

            // プレビューをクリア
            clearPreview();

            saveState();

            const minX = Math.min(rectangleStartX, rectangleEndX);
            const maxX = Math.max(rectangleStartX, rectangleEndX);
            const minY = Math.min(rectangleStartY, rectangleEndY);
            const maxY = Math.max(rectangleStartY, rectangleEndY);

            if (isFilledRectangleMode) {
                // 塗りつぶし矩形
                for (let x = minX; x <= maxX; x++) {
                    for (let y = minY; y <= maxY; y++) {
                        if (x < mapWidth && y < mapHeight) {
                            grid[x][y] = currentTerrain;
                        }
                    }
                }
                showToast(`塗りつぶし矩形を描画しました (${maxX - minX + 1}×${maxY - minY + 1})`, 'success');
            } else {
                // 矩形の枠線のみ
                for (let x = minX; x <= maxX; x++) {
                    if (x < mapWidth) {
                        if (minY < mapHeight) grid[x][minY] = currentTerrain; // 上辺
                        if (maxY < mapHeight) grid[x][maxY] = currentTerrain; // 下辺
                    }
                }
                for (let y = minY; y <= maxY; y++) {
                    if (y < mapHeight) {
                        if (minX < mapWidth) grid[minX][y] = currentTerrain; // 左辺
                        if (maxX < mapWidth) grid[maxX][y] = currentTerrain; // 右辺
                    }
                }
                showToast(`矩形の枠線を描画しました (${maxX - minX + 1}×${maxY - minY + 1})`, 'success');
            }

            update_texts();
            drawGrid();
        }

        // プレビュー矩形を描画する関数
        function drawPreviewRectangle() {
            if (rectangleStartX === null || rectangleStartY === null || !globalStage || !globalLayer) return;
            
            const minX = Math.min(rectangleStartX, rectangleEndX);
            const maxX = Math.max(rectangleStartX, rectangleEndX);
            const minY = Math.min(rectangleStartY, rectangleEndY);
            const maxY = Math.max(rectangleStartY, rectangleEndY);
            
            // 既存のプレビュー要素を削除
            const existingPreview = globalLayer.findOne('.preview-rectangle');
            if (existingPreview) {
                existingPreview.destroy();
            }
            
            // プレビューグループを作成
            const previewGroup = new Konva.Group({
                name: 'preview-rectangle'
            });
            
            // 範囲内の各セルを色反転で表示
            for (let x = minX; x <= maxX; x++) {
                for (let y = minY; y <= maxY; y++) {
                    if (x < mapWidth && y < mapHeight) {
                        // 色反転エフェクト用の矩形
                        const invertRect = new Konva.Rect({
                            x: x * gridSize,
                            y: y * gridSize,
                            width: gridSize,
                            height: gridSize,
                            fill: '#ffffff',
                            opacity: 0.4,
                            globalCompositeOperation: 'difference'
                        });
                        previewGroup.add(invertRect);
                        
                        // 塗りつぶしモードの場合は追加の色付けエフェクト
                        if (isFilledRectangleMode) {
                            const fillPreview = new Konva.Rect({
                                x: x * gridSize,
                                y: y * gridSize,
                                width: gridSize,
                                height: gridSize,
                                fill: '#ffff00', // 黄色でプレビュー
                                opacity: 0.3
                            });
                            previewGroup.add(fillPreview);
                        }
                        
                        // 境界線の描画
                        const shouldDrawBorder = 
                            (isFilledRectangleMode) || 
                            (x === minX || x === maxX || y === minY || y === maxY);
                        
                        if (shouldDrawBorder) {
                            const borderRect = new Konva.Rect({
                                x: x * gridSize,
                                y: y * gridSize,
                                width: gridSize,
                                height: gridSize,
                                stroke: isFilledRectangleMode ? '#ff6600' : '#ff0000', // 塗りつぶしはオレンジ、枠線は赤
                                strokeWidth: 2,
                                fill: 'transparent'
                            });
                            previewGroup.add(borderRect);
                        }
                    }
                }
            }
            
            // 点線の外枠を追加（塗りつぶしモードは太い線）
            const dashedBorder = new Konva.Rect({
                x: minX * gridSize - 1,
                y: minY * gridSize - 1,
                width: (maxX - minX + 1) * gridSize + 2,
                height: (maxY - minY + 1) * gridSize + 2,
                stroke: isFilledRectangleMode ? '#ff6600' : '#ff4444', // 塗りつぶしはオレンジ、枠線は赤
                strokeWidth: isFilledRectangleMode ? 4 : 3, // 塗りつぶしは太い線
                dash: isFilledRectangleMode ? [6, 3] : [8, 4], // 塗りつぶしは短い点線
                fill: 'transparent'
            });
            previewGroup.add(dashedBorder);
            
            // プレビューをレイヤーに追加
            globalLayer.add(previewGroup);
            globalLayer.draw();
        }        
        
        // プレビューをクリアする関数
        function clearPreview() {
            if (!globalLayer) return;
            
            // プレビュー要素を削除
            const existingPreview = globalLayer.findOne('.preview-rectangle');
            if (existingPreview) {
                existingPreview.destroy();
                globalLayer.draw();
            }
        }

        // グリッドサイズとマップサイズ
        let gridSize = 24; // タイルサイズ

        // タイルサイズの変更
        function updateTileSize() {
            const newSize = document.getElementById('tile_size').value;
            if (newSize > 0) {
                gridSize = newSize;
                drawGrid();
            }
        }

        let mapWidth = document.getElementById('vault-width').value;
        let mapHeight = document.getElementById('vault-height').value;
        let mapName = document.getElementById('vault-name').value;
        let mapID = document.getElementById('vault-id').value;
        let mapType = document.getElementById('vault-type').value;

        document.getElementById('vault-width').onchange = function () {
            saveState();
            mapWidth = document.getElementById('vault-width').value;
            drawGrid();
            update_texts();
        }

        document.getElementById('vault-height').onchange = function () {
            saveState();
            mapHeight = document.getElementById('vault-height').value;
            drawGrid();
            update_texts();
        }

        document.getElementById('vault-id').onchange = function () {
            mapID = document.getElementById('vault-id').value;
            update_texts();
        }

        document.getElementById('vault-type').onchange = function () {
            mapType = document.getElementById('vault-type').value;
            update_texts();
        }

        document.getElementById('vault-name').onchange = function () {
            mapName = document.getElementById('vault-name').value;
            update_texts();
        }

        const MapMaxSize = 300;
        let grid = Array.from({ length: MapMaxSize }, () => Array(MapMaxSize).fill(" "));
        let konva_text = Array.from({ length: MapMaxSize }, () => Array(MapMaxSize).fill(null));

        // グリッドを描画する関数
        function drawGrid() {
            // 既存のステージをクリア
            const tilesContainer = document.getElementById('tiles');
            tilesContainer.innerHTML = '';
            
            globalStage = new Konva.Stage({
                container: 'tiles',
                width: gridSize * mapWidth,
                height: gridSize * mapHeight
            });

            globalLayer = new Konva.Layer();
            konva_text = Array.from({ length: MapMaxSize }, () => Array(MapMaxSize).fill(null));
            globalStage.add(globalLayer);
            for (let i = 0; i < mapWidth; i++) {
                for (let j = 0; j < mapHeight; j++) {
                    const rect = new Konva.Rect({
                        x: i * gridSize,
                        y: j * gridSize,
                        width: gridSize,
                        height: gridSize,
                        fill: grid[i][j] === " " ? VOID_TILE_COLOR : NORMAL_TILE_COLOR,
                        stroke: 'white',
                        strokeWidth: 1
                    });

                    rect.on('mousedown', function () {
                        if (isFloodFillMode) {
                            // フラッドフィルモードの場合
                            const filled = floodFill(i, j, currentTerrain);
                            if (filled) {
                                showToast(`地形 "${grid[i][j]}" を "${currentTerrain}" で塗りつぶしました`, 'success');
                            }
                        } else if (isRectangleMode || isFilledRectangleMode) {
                            // 矩形描画モードの場合
                            if (!isDrawingRectangle) {
                                isDrawingRectangle = true;
                                rectangleStartX = i;
                                rectangleStartY = j;
                                rectangleEndX = i;
                                rectangleEndY = j;
                            }
                        } else {
                            // 通常モードの場合
                            saveState();
                            grid[i][j] = currentTerrain;
                            update_texts();
                            drawGrid();
                        }
                    });

                    konva_text[i][j] = new Konva.Text({
                        x: i * gridSize + 1,
                        y: j * gridSize + 1,
                        text: grid[i][j],
                        fontSize: gridSize,
                        fontFamily: 'Arial',
                        stroke: 'white',
                        listening: false,
                    });

                    gridUpdate = function () {
                        if (isRectangleMode || isFilledRectangleMode) {
                            // 矩形描画モードの場合
                            if (isDrawingRectangle) {
                                rectangleEndX = i;
                                rectangleEndY = j;
                                drawPreviewRectangle();
                            }
                        } else {
                            // 矩形描画モード以外の場合はプレビューをクリア
                            clearPreview();

                            if (mouseDown && !isFloodFillMode) {
                                grid[i][j] = currentTerrain;
                                this.fill(grid[i][j] === " " ? VOID_TILE_COLOR : NORMAL_TILE_COLOR);
                                konva_text[i][j].text(grid[i][j]);
                                globalLayer.draw();
                                update_texts();
                            }
                        }
                    };

                    if (touchmode) {
                        rect.on('touchmove', gridUpdate);
                    }
                    else {
                        rect.on('mousemove', gridUpdate);
                    }

                    globalLayer.add(rect);
                    globalLayer.add(konva_text[i][j]);
                }
            }
            globalLayer.draw();

            // 矩形描画用のステージイベントハンドラー
            globalStage.on('mouseup', function () {
                if ((isRectangleMode || isFilledRectangleMode) && isDrawingRectangle) {
                    isDrawingRectangle = false;
                    drawRectangle();
                    clearPreview();
                }
            });
        }
        window.onload = function () {
            loadTerrainDefinitions();
            drawGrid();
            update_texts();
        };

        function openDialog() {
            if (terrainDefinitions.length === 0) {
                alert('地形定義データを読み込み中です。しばらくお待ちください。');
                return;
            }
            updateSymbolDialog();
            // Bootstrapモーダルを表示
            const modal = new bootstrap.Modal(document.getElementById('symbolModal'));
            modal.show();
        }

        function openDeleteDialog() {
            updateDeleteDialog();
            // Bootstrapモーダルを表示
            const modal = new bootstrap.Modal(document.getElementById('deleteModal'));
            modal.show();
        }

        function updateDeleteDialog() {
            const deleteSelect = document.getElementById('deleteTerrainSelect');
            deleteSelect.innerHTML = '';

            // カスタム地形がない場合のメッセージ
            if (Object.keys(customTerrains).length === 0) {
                const option = document.createElement('option');
                option.value = '';
                option.textContent = '削除可能なカスタム地形がありません';
                option.disabled = true;
                deleteSelect.appendChild(option);
                return;
            }

            // カスタム地形のみを表示
            for (let symbol in customTerrains) {
                const terrain = customTerrains[symbol];
                const actualTerrainInfo = terrainDefinitions.find(t => t.id == terrain.actual);
                const visualTerrainInfo = terrainDefinitions.find(t => t.id == terrain.visual);

                const actualName = actualTerrainInfo ? (actualTerrainInfo.japaneName || actualTerrainInfo.englishName || actualTerrainInfo.name) : 'Unknown';
                const visualName = visualTerrainInfo ? (visualTerrainInfo.japaneName || visualTerrainInfo.englishName || visualTerrainInfo.name) : 'Unknown';

                let description = `実際: ${actualName}, 見た目: ${visualName}`;

                if (terrain.monster) {
                    const monsterInfo = monsterDefinitions.find(m => m.id == terrain.monster);
                    if (monsterInfo) {
                        const jaName = monsterInfo.name?.ja || monsterInfo.japaneName || '';
                        const enName = monsterInfo.name?.en || monsterInfo.englishName || monsterInfo.name || '';
                        const monsterName = jaName || enName || 'Unknown Monster';
                        description += `, モンスター: ${monsterName}`;
                    }
                }

                const option = document.createElement('option');
                option.value = symbol;
                option.textContent = `${symbol} - ${description}`;
                deleteSelect.appendChild(option);
            }
        }

        function deleteCustomTerrain() {
            const deleteSelect = document.getElementById('deleteTerrainSelect');
            const selectedSymbol = deleteSelect.value;

            if (!selectedSymbol) {
                alert('削除する地形を選択してください');
                return;
            }

            // 確認ダイアログ
            if (!confirm(`地形 "${selectedSymbol}" を削除しますか？この操作は取り消せません。`)) {
                return;
            }

            // 状態を保存
            saveState();

            // マップ上の削除対象地形をスペースに置き換え
            for (let i = 0; i < mapWidth; i++) {
                for (let j = 0; j < mapHeight; j++) {
                    if (grid[i][j] === selectedSymbol) {
                        grid[i][j] = ' ';
                    }
                }
            }

            // カスタム地形から削除
            delete customTerrains[selectedSymbol];

            // メインセレクトボックスからも削除
            const gridTypeSelect = document.getElementById('grid_type');
            const options = gridTypeSelect.options;
            for (let i = options.length - 1; i >= 0; i--) {
                if (options[i].value === selectedSymbol) {
                    gridTypeSelect.removeChild(options[i]);
                    break;
                }
            }

            // 現在選択中の地形が削除された地形だった場合、デフォルトに変更
            if (currentTerrain === selectedSymbol) {
                currentTerrain = '.';
                gridTypeSelect.value = '.';
            }

            // グリッドを再描画
            drawGrid();

            // 削除ダイアログを更新
            updateDeleteDialog();

            // テキストを更新
            update_texts();

            // モーダルを閉じる
            const modal = bootstrap.Modal.getInstance(document.getElementById('deleteModal'));
            if (modal) {
                modal.hide();
            }

            // 成功メッセージを表示
            showToast(`地形 "${selectedSymbol}" が削除されました。マップ上の該当地形はスペースに置き換えられました。`, 'success');
        }

        function closeDialog() {
            // Bootstrapモーダルを非表示
            const modal = bootstrap.Modal.getInstance(document.getElementById('symbolModal'));
            if (modal) {
                modal.hide();
            }
        }

        function addSymbolToSelect(symbol) {
            let selectBox = document.querySelector('select');
            let option = document.createElement('option');
            option.value = symbol;
            option.text = `${symbol} - 新規地形`;
            selectBox.add(option);
        }

        function defineSymbol() {
            let newSymbol = document.getElementById('symbolInput').value;
            if (newSymbol.length === 1) {
                currentTerrain = newSymbol;
                addSymbolToSelect(newSymbol);
                closeDialog();
            }
        }

        // TerrainDefinitions.txtから地形データを取得
        function loadTerrainDefinitions() {
            fetch('https://raw.githubusercontent.com/deskull-m/bakabakaband/refs/heads/master/lib/edit/TerrainDefinitions.txt')
                .then(response => response.text())
                .then(text => {
                    const lines = text.split('\n');
                    let currentTerrain = {};

                    for (let line of lines) {
                        line = line.trim();
                        if (line.startsWith('N:')) {
                            // 前の地形があれば保存
                            if (currentTerrain.id !== undefined) {
                                terrainDefinitions.push({ ...currentTerrain });
                            }
                            // 新しい地形の開始
                            const match = line.match(/N:(\d+):(.+)/);
                            if (match) {
                                currentTerrain = {
                                    id: parseInt(match[1]),
                                    name: match[2]
                                };
                            }
                            if (!currentTerrain.tags) {
                                currentTerrain.tags = [];
                            }
                            currentTerrain.tags.push(currentTerrain.name);
                        } else if (line.startsWith('J:')) {
                            currentTerrain.japaneName = line.substring(2);
                        } else if (line.startsWith('E:')) {
                            currentTerrain.englishName = line.substring(2);
                        }
                    }

                    // 最後の地形も保存
                    if (currentTerrain.id !== undefined) {
                        terrainDefinitions.push(currentTerrain);
                    }

                    console.log('地形定義データを読み込みました:', terrainDefinitions.length, '件');

                    // モンスターデータも読み込み
                    loadMonsterDefinitions();
                })
                .catch(error => {
                    console.error('地形定義データの読み込みに失敗しました:', error);
                });
        }

        // MonraceDefinitions.jsoncからモンスターデータを取得
        function loadMonsterDefinitions() {
            fetch('https://raw.githubusercontent.com/deskull-m/bakabakaband/refs/heads/master/lib/edit/MonraceDefinitions.jsonc')
                .then(response => response.text())
                .then(text => {
                    // JSONCのコメントを除去
                    const jsonText = text.replace(/\/\*[\s\S]*?\*\//g, '').replace(/\/\/.*$/gm, '');
                    const data = JSON.parse(jsonText);

                    // データ構造を確認してmonsterDefinitionsを設定
                    if (data.monsters) {
                        monsterDefinitions = data.monsters;
                    } else if (Array.isArray(data)) {
                        monsterDefinitions = data;
                    } else {
                        monsterDefinitions = [];
                    }

                    console.log('モンスター定義データを読み込みました:', monsterDefinitions.length, '件');
                    console.log('サンプルモンスター:', monsterDefinitions[0]); // デバッグ用
                })
                .catch(error => {
                    console.error('モンスター定義データの読み込みに失敗しました:', error);
                    // エラーでも地形定義は使用可能にする
                    monsterDefinitions = [];
                });
        }

        // 新規地形定義ダイアログのHTML更新
        function updateSymbolDialog() {
            // 地形セレクトボックスを初期化
            populateActualTerrain();
            populateVisualTerrain();

            // モンスターセレクトボックスを更新
            populateMonsterSelect();

            // イベントリスナーを追加（既存のリスナーをクリア）
            const actualSelect = document.getElementById('actualTerrain');
            const visualSelect = document.getElementById('visualTerrain');

            actualSelect.removeEventListener('change', onActualTerrainChange);
            visualSelect.removeEventListener('change', onVisualTerrainChange);

            actualSelect.addEventListener('change', onActualTerrainChange);
            visualSelect.addEventListener('change', onVisualTerrainChange);
        }

        // 実際の地形セレクトボックスを更新する関数
        function populateActualTerrain(filterText = '') {
            const actualSelect = document.getElementById('actualTerrain');
            actualSelect.innerHTML = '<option value="">選択してください</option>';

            const filteredTerrains = terrainDefinitions.filter(terrain => {
                if (!filterText) return true;

                const baseName = terrain.japaneName || terrain.englishName || terrain.name || '';
                const tagsText = terrain.tags ? terrain.tags.join(' ') : '';
                const searchText = filterText.toLowerCase();

                return baseName.toLowerCase().includes(searchText) ||
                    tagsText.toLowerCase().includes(searchText) ||
                    terrain.id.toString().includes(searchText);
            });

            filteredTerrains.forEach(terrain => {
                const baseName = terrain.japaneName || terrain.englishName || terrain.name;
                let displayName = `${terrain.id}: ${baseName}`;

                if (terrain.tags && terrain.tags.length > 0) {
                    const tagsText = terrain.tags.join(', ');
                    displayName += ` (${tagsText})`;
                }

                const option = document.createElement('option');
                option.value = terrain.id;
                option.textContent = displayName;
                actualSelect.appendChild(option);
            });

            // 検索結果の件数を表示
            const filterInput = document.getElementById('actualTerrainFilter');
            if (filterText && filterInput) {
                filterInput.placeholder = `${filteredTerrains.length}件見つかりました`;
            } else if (filterInput) {
                filterInput.placeholder = '地形名で検索...';
            }
        }

        // 見た目の地形セレクトボックスを更新する関数
        function populateVisualTerrain(filterText = '') {
            const visualSelect = document.getElementById('visualTerrain');
            visualSelect.innerHTML = '<option value="">選択してください</option>';

            const filteredTerrains = terrainDefinitions.filter(terrain => {
                if (!filterText) return true;

                const baseName = terrain.japaneName || terrain.englishName || terrain.name || '';
                const tagsText = terrain.tags ? terrain.tags.join(' ') : '';
                const searchText = filterText.toLowerCase();

                return baseName.toLowerCase().includes(searchText) ||
                    tagsText.toLowerCase().includes(searchText) ||
                    terrain.id.toString().includes(searchText);
            });

            filteredTerrains.forEach(terrain => {
                const baseName = terrain.japaneName || terrain.englishName || terrain.name;
                let displayName = `${terrain.id}: ${baseName}`;

                if (terrain.tags && terrain.tags.length > 0) {
                    const tagsText = terrain.tags.join(', ');
                    displayName += ` (${tagsText})`;
                }

                const option = document.createElement('option');
                option.value = terrain.id;
                option.textContent = displayName;
                visualSelect.appendChild(option);
            });

            // 検索結果の件数を表示
            const filterInput = document.getElementById('visualTerrainFilter');
            if (filterText && filterInput) {
                filterInput.placeholder = `${filteredTerrains.length}件見つかりました`;
            } else if (filterInput) {
                filterInput.placeholder = '地形名で検索...';
            }
        }

        // 実際の地形フィルター機能
        function filterActualTerrain() {
            const filterText = document.getElementById('actualTerrainFilter').value;
            populateActualTerrain(filterText);
        }

        // 見た目の地形フィルター機能
        function filterVisualTerrain() {
            const filterText = document.getElementById('visualTerrainFilter').value;
            populateVisualTerrain(filterText);
        }

        // 実際の地形フィルターをクリア
        function clearActualTerrainFilter() {
            document.getElementById('actualTerrainFilter').value = '';
            populateActualTerrain();
        }

        // 見た目の地形フィルターをクリア
        function clearVisualTerrainFilter() {
            document.getElementById('visualTerrainFilter').value = '';
            populateVisualTerrain();
        }

        // モンスターセレクトボックスを更新する関数
        function populateMonsterSelect(filterText = '') {
            const monsterSelect = document.getElementById('monsterSelect');
            monsterSelect.innerHTML = '<option value="">なし</option>';

            const filteredMonsters = monsterDefinitions.filter(monster => {
                if (!filterText) return true;

                const jaName = monster.name?.ja || monster.japaneName || '';
                const enName = monster.name?.en || monster.englishName || monster.name || '';
                const searchText = filterText.toLowerCase();

                return jaName.toLowerCase().includes(searchText) ||
                    enName.toLowerCase().includes(searchText) ||
                    monster.id.toString().includes(searchText);
            });

            filteredMonsters.forEach(monster => {
                const option = document.createElement('option');
                option.value = monster.id;

                // モンスター表示形式: ID: symbol Lv## 日本語名 / 英語名
                let displayName = '';
                if (monster.id !== undefined) {
                    displayName = `${monster.id}: `;

                    if (monster.symbol && monster.symbol.character) {
                        displayName += `${monster.symbol.character} `;
                    }

                    if (monster.level !== undefined) {
                        displayName += `Lv${monster.level} `;
                    }

                    // 日本語名と英語名を並列表示
                    const jaName = monster.name?.ja || monster.japaneName || '';
                    const enName = monster.name?.en || monster.englishName || monster.name || '';

                    if (jaName && enName && jaName !== enName) {
                        displayName += `${jaName.substring(0, 30)} / ${enName.substring(0, 30)}`;
                    } else if (jaName) {
                        displayName += jaName.substring(0, 30);
                    } else if (enName) {
                        displayName += enName.substring(0, 30);
                    } else {
                        displayName += 'Unknown Monster';
                    }
                } else {
                    displayName = 'Invalid Monster Data';
                }

                option.textContent = displayName;
                monsterSelect.appendChild(option);
            });

            // 検索結果の件数を表示
            const filterInput = document.getElementById('monsterFilter');
            if (filterText && filterInput) {
                filterInput.placeholder = `${filteredMonsters.length}件見つかりました`;
            } else if (filterInput) {
                filterInput.placeholder = 'モンスター名で検索...';
            }
        }

        // モンスターフィルター機能
        function filterMonsters() {
            const filterText = document.getElementById('monsterFilter').value;
            populateMonsterSelect(filterText);
        }

        // モンスターフィルターをクリア
        function clearMonsterFilter() {
            document.getElementById('monsterFilter').value = '';
            populateMonsterSelect();
        }

        // 実際の地形セレクトボックスの変更イベント
        function onActualTerrainChange() {
            const actualSelect = document.getElementById('actualTerrain');
            const visualSelect = document.getElementById('visualTerrain');

            // 見た目の地形が未選択の場合、同じ値に設定
            if (actualSelect.value && !visualSelect.value) {
                visualSelect.value = actualSelect.value;
            }
        }

        // 見た目の地形セレクトボックスの変更イベント
        function onVisualTerrainChange() {
            const actualSelect = document.getElementById('actualTerrain');
            const visualSelect = document.getElementById('visualTerrain');

            // 実際の地形が未選択の場合、同じ値に設定
            if (visualSelect.value && !actualSelect.value) {
                actualSelect.value = visualSelect.value;
            }
        }

        function defineCustomTerrain() {
            const symbol = document.getElementById('symbolInput').value;
            const actualTerrain = document.getElementById('actualTerrain').value;
            const visualTerrain = document.getElementById('visualTerrain').value;
            const monsterId = document.getElementById('monsterSelect').value;

            if (!symbol || symbol.length !== 1) {
                alert('1文字のシンボルを入力してください');
                return;
            }

            if (!actualTerrain) {
                alert('実際の地形を選択してください');
                return;
            }

            if (!visualTerrain) {
                alert('見た目の地形を選択してください');
                return;
            }

            // 状態を保存
            saveState();

            // カスタム地形を保存
            customTerrains[symbol] = {
                actual: actualTerrain,
                visual: visualTerrain,
                monster: monsterId || null
            };

            // 現在の地形として設定
            currentTerrain = symbol;

            // メインの地形選択セレクトボックスに追加
            addSymbolToMainSelect(symbol);

            // フォームをクリア
            document.getElementById('symbolInput').value = '';
            document.getElementById('actualTerrain').value = '';
            document.getElementById('visualTerrain').value = '';
            document.getElementById('monsterSelect').value = '';

            closeDialog();

            // Bootstrapトーストで成功メッセージを表示
            showToast(`新規地形 "${symbol}" が定義されました`, 'success');
        }

        function addSymbolToMainSelect(symbol) {
            const selectBox = document.getElementById('grid_type');
            const option = document.createElement('option');
            option.value = symbol;

            // 実際の地形と見た目の地形の情報を表示
            const terrainData = customTerrains[symbol];
            const actualTerrainInfo = terrainDefinitions.find(t => t.id == terrainData.actual);
            const visualTerrainInfo = terrainDefinitions.find(t => t.id == terrainData.visual);

            const actualName = actualTerrainInfo ? (actualTerrainInfo.japaneName || actualTerrainInfo.englishName || actualTerrainInfo.name) : 'Unknown';
            const visualName = visualTerrainInfo ? (visualTerrainInfo.japaneName || visualTerrainInfo.englishName || visualTerrainInfo.name) : 'Unknown';

            let description = `${actualName}(${actualTerrainInfo.tags.join(', ')}) 見た目: ${visualName}(${visualTerrainInfo.tags.join(', ')})`;

            if (terrainData.monster) {
                const monsterInfo = monsterDefinitions.find(m => m.id == terrainData.monster);
                let monsterName = 'Unknown Monster';

                if (monsterInfo) {
                    // モンスター名を適切に取得
                    const jaName = monsterInfo.name?.ja || monsterInfo.japaneName || '';
                    const enName = monsterInfo.name?.en || monsterInfo.englishName || monsterInfo.name || '';

                    if (jaName && enName && jaName !== enName) {
                        monsterName = `${jaName} / ${enName}`;
                    } else if (jaName) {
                        monsterName = jaName;
                    } else if (enName) {
                        monsterName = enName;
                    }
                }

                description += `, モンスター: ${monsterName}`;
            }

            description += ')';

            option.textContent = `${symbol} - ${description}`;
            selectBox.appendChild(option);

            // 新しく追加した地形を選択状態にする
            selectBox.value = symbol;
        }
        // Bootstrapトーストを表示する関数
        function showToast(message, type = 'info') {
            // トーストコンテナがなければ作成
            let toastContainer = document.getElementById('toast-container');
            if (!toastContainer) {
                toastContainer = document.createElement('div');
                toastContainer.id = 'toast-container';
                toastContainer.className = 'toast-container position-fixed top-50 start-50 translate-middle';
                toastContainer.style.zIndex = '9999';
                document.body.appendChild(toastContainer);
            }

            // トーストHTMLを作成
            const toastId = 'toast-' + Date.now();
            const toastHtml = `
                <div id="${toastId}" class="toast" role="alert" aria-live="assertive" aria-atomic="true" style="opacity: 0; transition: opacity 0.3s ease-in-out;">
                    <div class="toast-header">
                        <span class="badge bg-${type === 'success' ? 'success' : 'info'} me-2"></span>
                        <strong class="me-auto">地形エディタ</strong>
                        <small>今</small>
                        <button type="button" class="btn-close" data-bs-dismiss="toast" aria-label="Close"></button>
                    </div>
                    <div class="toast-body">
                        ${message}
                    </div>
                </div>
            `;

            // トーストを追加
            toastContainer.insertAdjacentHTML('beforeend', toastHtml);

            // Bootstrapトーストを初期化
            const toastElement = document.getElementById(toastId);
            const toast = new bootstrap.Toast(toastElement, {
                autohide: true,
                delay: 3000
            });

            // フェードイン効果
            setTimeout(() => {
                toastElement.style.opacity = '1';
            }, 100);

            // トーストを表示
            toast.show();

            // 2.5秒後にフェードアウト開始
            setTimeout(() => {
                toastElement.style.opacity = '0';
            }, 2500);

            // トーストが非表示になったら要素を削除
            toastElement.addEventListener('hidden.bs.toast', function () {
                toastElement.remove();
            });

            // フェードアウト完了後に強制的に削除（念のため）
            setTimeout(() => {
                if (toastElement.parentNode) {
                    toastElement.remove();
                }
            }, 3300);
        }

        function parseTextToGUI() {
            const text = document.getElementById('v_info').value;
            const lines = text.split(/\r?\n/);
            let error = null;
            try {
                const nMatch = lines[0].match(/^N:(\d+):(.*)$/);
                if (!nMatch) throw "N:ブロックの定義が不正です";
                document.getElementById('vault-id').value = nMatch[1];
                document.getElementById('vault-name').value = nMatch[2];

                const xMatch = lines[1].match(/^X:(\d+):(\d+):(\d+):(\d+)$/);
                if (!xMatch) throw "X:ブロックの定義が不正です";
                document.getElementById('vault-type').value = xMatch[1];
                document.getElementById('vault-height').value = xMatch[3];
                document.getElementById('vault-width').value = xMatch[4];

                // F:行を解析
                customTerrains = {};
                let dataLineStart = 2;
                for (let i = 2; i < lines.length; i++) {
                    const line = lines[i];
                    if (line.startsWith('F:')) {
                        const fMatch = line.match(/^F:(\w):(\d+):(\d+)$/);
                        if (fMatch) {
                            // F:行から地形定義を復元（シンボルは後で判定）
                            dataLineStart = i + 1;
                        } else {
                            throw `F:ブロック${i}行目が不正です`;
                        }
                    } else if (line.startsWith('D:')) {
                        dataLineStart = i;
                        break;
                    }
                }

                // グリッドデータを解析
                let gridData = [];
                for (let j = 0; j < parseInt(xMatch[3]); j++) {
                    const dLine = lines[dataLineStart + j];
                    if (!dLine || !dLine.startsWith('D:')) throw `D:ブロック${j}行目が不正です`;
                    const row = dLine.slice(2);
                    if (row.length !== parseInt(xMatch[4])) throw `D:ブロック${j}行目の長さが幅と一致しません`;
                    gridData.push(row.split(''));
                }

                for (let i = 0; i < gridData[0].length; i++) {
                    for (let j = 0; j < gridData.length; j++) {
                        grid[i][j] = gridData[j][i];
                    }
                }

                mapID = nMatch[1];
                mapName = nMatch[2];
                mapType = xMatch[1];
                mapHeight = parseInt(xMatch[3]);
                mapWidth = parseInt(xMatch[4]);
                drawGrid();
            } catch (e) {
                error = e;
            }
            showParseError(error);
        }

        function showParseError(msg) {
            let errDiv = document.getElementById('parse-error');
            if (!errDiv) {
                errDiv = document.createElement('div');
                errDiv.id = 'parse-error';
                errDiv.style.color = 'red';
                document.getElementById('texts').appendChild(errDiv);
            }
            errDiv.textContent = msg ? `構文エラー: ${msg}` : '';
            errDiv.style.display = msg ? 'block' : 'none';
        }

        document.getElementById('v_info').addEventListener('input', parseTextToGUI);

        // キーボードショートカットの追加
        document.addEventListener('keydown', function (e) {
            // Ctrl+Z または Cmd+Z でアンドゥ
            if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
                e.preventDefault();
                undo();
            }
            // Ctrl+Y または Ctrl+Shift+Z または Cmd+Y または Cmd+Shift+Z でリドゥ
            else if (((e.ctrlKey || e.metaKey) && e.key === 'y') ||
                ((e.ctrlKey || e.metaKey) && e.shiftKey && e.key === 'Z')) {
                e.preventDefault();
                redo();
            }
            // Fキーでフラッドフィルモード切り替え
            else if (e.key === 'f' || e.key === 'F') {
                e.preventDefault();
                const floodFillMode = document.getElementById('floodFillMode');
                floodFillMode.checked = true;
                setDrawingMode();
            }
            // Dキーで通常描画モード切り替え
            else if (e.key === 'd' || e.key === 'D') {
                e.preventDefault();
                const normalMode = document.getElementById('normalMode');
                normalMode.checked = true;
                setDrawingMode();
            }
            // Rキーで矩形描画モード切り替え
            else if ((e.key === 'r' || e.key === 'R') && !e.shiftKey) {
                e.preventDefault();
                const rectangleMode = document.getElementById('rectangleMode');
                rectangleMode.checked = true;
                setDrawingMode();
            }
            // Shift+Rで塗りつぶし矩形モード切り替え
            else if ((e.key === 'r' || e.key === 'R') && e.shiftKey) {
                e.preventDefault();
                const filledRectangleMode = document.getElementById('filledRectangleMode');
                filledRectangleMode.checked = true;
                setDrawingMode();
            }
        });

        // 初期状態を保存（ページ読み込み完了後）
        window.addEventListener('load', function () {
            // 少し遅延させて初期状態を保存
            setTimeout(saveState, 100);
        });

    </script>
</body>

<script type="text/babel">
    const VERSION = "0.0.2";
    function App() {
        return (
            <div>
                <pre>*band Vault Editor by Deskull. Ver.{VERSION}</pre>
            </div>
        );
    }

    function SlideUp() {
        saveState();
        for (let i = 0; i < mapWidth; i++) {
            for (let j = 0; j < mapHeight - 1; j++) {
                grid[i][j] = grid[i][j + 1];
            }
        }
        drawGrid();
        update_texts();
    }

    function SlideLeft() {
        saveState();
        for (let i = 0; i < mapWidth - 1; i++) {
            for (let j = 0; j < mapHeight; j++) {
                grid[i][j] = grid[i + 1][j];
            }
        }
        drawGrid();
        update_texts();
    }

    function SlideRight() {
        saveState();
        for (let i = mapWidth - 1; i > 0; i--) {
            for (let j = 0; j < mapHeight; j++) {
                grid[i][j] = grid[i - 1][j];
            }
        }
        drawGrid();
        update_texts();
    }

    function SlideDown() {
        saveState();
        for (let i = 0; i < mapWidth; i++) {
            for (let j = mapHeight - 1; j > 0; j--) {
                grid[i][j] = grid[i][j - 1];
            }
        }
        drawGrid();
        update_texts();
    }

    function SlideKeys() {
        return (
            <div className="container-fluid">
                <div className="row mb-2">
                    <div className="col-12 text-center">
                        <div className="btn-group" role="group" aria-label="スライド操作">
                            <button className="btn btn-outline-primary btn-sm" onClick={SlideUp} title="上にスライド">
                                <i className="bi bi-arrow-up"></i>
                            </button>
                            <button className="btn btn-outline-primary btn-sm" onClick={SlideDown} title="下にスライド">
                                <i className="bi bi-arrow-down"></i>
                            </button>
                            <button className="btn btn-outline-primary btn-sm" onClick={SlideLeft} title="左にスライド">
                                <i className="bi bi-arrow-left"></i>
                            </button>
                            <button className="btn btn-outline-primary btn-sm" onClick={SlideRight} title="右にスライド">
                                <i className="bi bi-arrow-right"></i>
                            </button>
                        </div>
                    </div>
                </div>
                <div className="row mb-2">
                    <div className="col-12 text-center">
                        <div className="btn-group" role="group" aria-label="回転操作">
                            <button className="btn btn-outline-success btn-sm" onClick={RotateLeft} title="左回転">
                                <i className="bi bi-arrow-counterclockwise"></i>
                            </button>
                            <button className="btn btn-outline-success btn-sm" onClick={RotateRight} title="右回転">
                                <i className="bi bi-arrow-clockwise"></i>
                            </button>
                        </div>
                    </div>
                </div>
                <div className="row mb-2">
                    <div className="col-12 text-center">
                        <div className="btn-group" role="group" aria-label="反転操作">
                            <button className="btn btn-outline-warning btn-sm" onClick={ReverseGridLeftRight} title="左右反転">
                                <i className="bi bi-arrow-left-right"></i>
                            </button>
                            <button className="btn btn-outline-warning btn-sm" onClick={ReverseGridUpDown} title="上下反転">
                                <i className="bi bi-arrow-down-up"></i>
                            </button>
                        </div>
                    </div>
                </div>
                <div className="row mb-2">
                    <div className="col-12 text-center">
                        <button className="btn btn-outline-info btn-sm" onClick={CoatingOutsideVault} title="外周に%を配置">
                            <i className="bi bi-percent"></i>
                        </button>
                    </div>
                </div>
                <div className="row mb-2">
                    <div className="col-12 text-center">
                        <div className="btn-group" role="group" aria-label="ミラー操作">
                            <button className="btn btn-outline-secondary btn-sm" onClick={MirrorGridLeftToRight} title="左から右へミラー">
                                <i className="bi bi-chevron-double-right"></i>
                            </button>
                            <button className="btn btn-outline-secondary btn-sm" onClick={MirrorGridTopToBottom} title="上から下へミラー">
                                <i className="bi bi-chevron-double-down"></i>
                            </button>
                            <button className="btn btn-outline-secondary btn-sm" onClick={MirrorGridDiagonal} title="対角線ミラー">
                                <i className="bi bi-slash-lg"></i>
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        );
    }

    function CoatingOutsideVault() {
        saveState();
        for (let i = 0; i < mapWidth; i++) {
            for (let j = 0; j < mapHeight; j++) {
                if (grid[i][j] !== " ") {
                    continue
                }

                if (i > 0 && grid[i - 1][j] !== " " && grid[i - 1][j] !== "%") {
                    grid[i][j] = "%";
                    continue;
                }

                if (j > 0 && grid[i][j - 1] !== " " && grid[i][j - 1] !== "%") {
                    grid[i][j] = "%";
                    continue;
                }

                if (j < mapHeight - 1 && grid[i][j + 1] !== " " && grid[i][j + 1] !== "%") {
                    grid[i][j] = "%";
                    continue;
                }

                if (i < mapWidth - 1 && grid[i + 1][j] !== " " && grid[i + 1][j] !== "%") {
                    grid[i][j] = "%";
                    continue;
                }
            }
        }
        drawGrid();
        update_texts();
    }

    function RotateLeft() {
        saveState();
        let newGrid = Array.from({ length: mapHeight }, () => Array(mapWidth).fill(" "));
        for (let i = 0; i < mapWidth; i++) {
            for (let j = 0; j < mapHeight; j++) {
                newGrid[j][mapWidth - i - 1] = grid[i][j];
            }
        }
        grid = newGrid;
        let tmp = mapWidth;
        mapWidth = mapHeight;
        mapHeight = tmp;
        drawGrid();
        update_texts();
    }

    function RotateRight() {
        saveState();
        let newGrid = Array.from({ length: mapHeight }, () => Array(mapWidth).fill(" "));
        for (let i = 0; i < mapWidth; i++) {
            for (let j = 0; j < mapHeight; j++) {
                newGrid[mapHeight - j - 1][i] = grid[i][j];
            }
        }
        grid = newGrid;
        let tmp = mapWidth;
        mapWidth = mapHeight;
        mapHeight = tmp;
        drawGrid();
        update_texts();
    }

    function ReverseGridLeftRight() {
        saveState();
        let newGrid = Array.from({ length: mapWidth }, () => Array(mapHeight).fill(" "));
        for (let i = 0; i < mapWidth; i++) {
            for (let j = 0; j < mapHeight; j++) {
                newGrid[i][j] = grid[mapWidth - i - 1][j];
            }
        }
        grid = newGrid;
        drawGrid();
        update_texts();
    }

    function ReverseGridUpDown() {
        saveState();
        let newGrid = Array.from({ length: mapWidth }, () => Array(mapHeight).fill(" "));
        for (let i = 0; i < mapWidth; i++) {
            for (let j = 0; j < mapHeight; j++) {
                newGrid[i][j] = grid[i][mapHeight - j - 1];
            }
        }
        grid = newGrid;
        drawGrid();
        update_texts();
    }

    function MirrorGridLeftToRight() {
        saveState();
        for (let j = 0; j < mapHeight; j++) {
            for (let i = 0; i < Math.floor(mapWidth / 2); i++) {
                grid[mapWidth - 1 - i][j] = grid[i][j];
            }
        }
        drawGrid();
        update_texts();
    }

    function MirrorGridTopToBottom() {
        saveState();
        for (let i = 0; i < mapWidth; i++) {
            for (let j = 0; j < Math.floor(mapHeight / 2); j++) {
                grid[i][mapHeight - 1 - j] = grid[i][j];
            }
        }
        drawGrid();
        update_texts();
    }

    // 左下から右上への対角線でミラー
    function MirrorGridDiagonal() {
        saveState();
        for (let i = 0; i < Math.min(mapWidth, mapHeight); i++) {
            for (let j = i + 1; j < Math.min(mapWidth, mapHeight); j++) {
                grid[j][i] = grid[i][j];
            }
        }
        drawGrid();
        update_texts();
    }

    function ToggleButton() {
        const [isOn, setIsOn] = React.useState(false);

        const toggleButton = () => {
            if (isOn) {
                document.getElementById('editor').style.display = 'flex';
            }
            else {
                document.getElementById('editor').style.display = 'none';
            }
            setIsOn(!isOn);
        };

        return (
            <button onClick={toggleButton} type="button" id="toggle-button">
                {isOn ? '>>' : '<<'}
            </button>
        );
    }

    // ReactDOMを使ってコンポーネントをレンダリング
    ReactDOM.render(<ToggleButton />, document.getElementById('toggle'));


    // Rendering the App component to the DOM
    ReactDOM.createRoot(document.getElementById('version')).render(<App />);
    ReactDOM.createRoot(document.getElementById('slide_keys')).render(<SlideKeys />);
</script>

</html>