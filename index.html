<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vault Editor</title>
    <link href="editor.css" rel="stylesheet">

    <!-- Custom Responsive Styles -->
    <style>
        /* レスポンシブ対応のカスタムスタイル */
        @media (max-width: 768px) {
            .container-fluid {
                padding: 0 10px;
            }

            .card-body {
                padding: 1rem 0.5rem;
            }

            .form-control-sm,
            .form-select-sm {
                font-size: 0.8rem;
            }

            .btn-sm {
                padding: 0.25rem 0.5rem;
                font-size: 0.75rem;
            }

            .small {
                font-size: 0.75rem;
            }

            #tiles {
                max-height: 50vh;
            }

            .navbar-brand {
                font-size: 1rem;
            }
        }

        @media (max-width: 576px) {
            .row {
                margin: 0;
            }

            .col-lg-3,
            .col-lg-6,
            .col-lg-3 {
                padding: 0 5px;
            }

            .card-header h5 {
                font-size: 0.9rem;
            }

            #tiles {
                max-height: 40vh;
            }

            .form-check-label {
                font-size: 0.7rem;
            }
        }

        /* タッチデバイス対応 */
        @media (hover: none) and (pointer: coarse) {
            .btn {
                min-height: 44px;
            }

            .form-control,
            .form-select {
                min-height: 44px;
            }

            .form-check-input {
                width: 1.2em;
                height: 1.2em;
            }

            /* タッチデバイスでキーボードショートカットを非表示 */
            .keyboard-shortcut {
                display: none;
            }
        }

        /* デスクトップでのキーボードショートカット表示 */
        @media (hover: hover) and (pointer: fine) {
            .keyboard-shortcut {
                opacity: 0.7;
                font-size: 0.7rem;
            }
        }

        /* カードの高さを画面サイズに合わせて調整 */
        .card-container {
            min-height: calc(100vh - 120px);
        }

        @media (max-width: 768px) {
            .card-container {
                min-height: auto;
                margin-bottom: 1rem;
            }
        }

        /* カンバスエリアの最適化 */
        #tiles {
            background: #1a1a1a;
            border-radius: 0.375rem;
            touch-action: manipulation;
        }

        /* モーダルのレスポンシブ対応 */
        @media (max-width: 768px) {
            .modal-dialog {
                margin: 0.5rem;
            }

            .modal-lg {
                max-width: calc(100vw - 1rem);
            }
        }

        /* スクロールバーのスタイリング */
        .overflow-auto::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        .overflow-auto::-webkit-scrollbar-track {
            background: #2c2c2c;
            border-radius: 4px;
        }

        .overflow-auto::-webkit-scrollbar-thumb {
            background: #5a5a5a;
            border-radius: 4px;
        }

        .overflow-auto::-webkit-scrollbar-thumb:hover {
            background: #6a6a6a;
        }
    </style>

    <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/konva/8.3.9/konva.min.js"></script>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet"
        integrity="sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.0/font/bootstrap-icons.css">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.bundle.min.js"
        integrity="sha384-MrcW6ZMFYlzcLA8Nl+NtUVF0sA7MsXsP1UyJoMp4YLEuNSfAP+JcXn/tWtIaxVXM"
        crossorigin="anonymous"></script>
</head>

<body class="bg-dark text-light">
    <!-- App Header - Fixed Top Right -->
    <div id="version"></div>

    <!-- Main Container -->
    <div class="container-fluid pt-2">
        <div class="row g-3">
            <!-- Left Sidebar - Controls -->
            <div class="col-lg-3 col-md-4 col-12 order-2 order-md-1">
                <div class="card bg-secondary card-container" style="flex: 0 0 auto;">
                    <div class="card-header">
                        <h5 class="card-title mb-0">
                            <i class="bi bi-gear"></i> 設定
                        </h5>
                    </div>
                    <div class="card-body overflow-auto">
                        <!-- Vault Parameters -->
                        <div class="mb-3">
                            <h6 class="text-warning mb-2">基本設定</h6>
                            <div class="row g-1 mb-2">
                                <div class="col-3">
                                    <label class="form-label small">ID</label>
                                    <input type="number" class="form-control form-control-sm" id="vault-id"
                                        name="vault-id" min="0" value="0">
                                </div>
                                <div class="col-3">
                                    <label class="form-label small">種別</label>
                                    <input type="number" class="form-control form-control-sm" id="vault-type"
                                        name="vault-type" min="0" value="18">
                                </div>
                                <div class="col-3">
                                    <label class="form-label small">幅</label>
                                    <input type="number" class="form-control form-control-sm" id="vault-width"
                                        name="vault-width" min="3" max="240" value="14">
                                </div>
                                <div class="col-3">
                                    <label class="form-label small">高さ</label>
                                    <input type="number" class="form-control form-control-sm" id="vault-height"
                                        name="vault-height" min="3" max="240" value="14">
                                </div>
                            </div>
                            <div class="row g-1">
                                <div class="col-12">
                                    <label class="form-label small">名前</label>
                                    <input type="text" class="form-control form-control-sm" id="vault-name"
                                        name="vault-name" value="" placeholder="部屋名">
                                </div>
                            </div>
                        </div>

                        <!-- Terrain Selection -->
                        <div class="mb-3">
                            <h6 class="text-warning mb-2">地形選択</h6>
                            <select id="grid_type" class="form-select form-select-sm">
                                <option value=".">. - Floor</option>
                                <option value=" ">SPACE - None</option>
                                <option value="%">% - outside of the vault, where corridors may be connected</option>
                                <option value="#"># - granite</option>
                                <option value="$">$ - glass wall</option>
                                <option value="X">X - impenetrable rock</option>
                                <option value="Y">Y - impenetrable glass wall</option>
                                <option value="*">* - treasure or trap</option>
                                <option value="+">+ - secret door</option>
                                <option value="-">- - secret glass door</option>
                                <option value="'">' - curtain</option>
                                <option value="^">^ - trap</option>
                                <option value="&">& - monster up to 5 levels out of depth (OOD)</option>
                                <option value="@">@ - monster up to 11 levels OOD</option>
                                <option value="9">9 - monster up to 9 levels OOD and treasure up to 7 levels OOD
                                </option>
                                <option value="8">8 - monster up to 40 levels OOD and treasure up to 20 levels OOD
                                </option>
                                <option value=",">, - monster up to 3 levels OOD and/or treasure up to 7 levels OOD
                                </option>
                                <option value=":">: - tree</option>
                                <option value="[">[ - treasure</option>
                                <option value="~">~ - shallow water</option>
                                <option value="=">= - deep water</option>
                                <option value="v">v - shallow lava</option>
                                <option value="w">w - deep lava</option>
                                <option value="f">f - shallow acid puddle</option>
                                <option value="F">F - deep acid puddle</option>
                                <option value="g">g - shallow poisonous puddle</option>
                                <option value="G">G - deep poisonous puddle</option>
                                <option value="h">h - cold zone</option>
                                <option value="H">H - heavy cold zone</option>
                                <option value="i">i - electrical zone</option>
                                <option value="I">I - heavy electrical zone</option>
                            </select>
                        </div>

                        <!-- Custom Terrain -->
                        <div class="mb-3">
                            <h6 class="text-warning mb-2">カスタム地形</h6>
                            <div class="row g-1">
                                <div class="col-6">
                                    <button onclick="openDialog()" class="btn btn-warning btn-sm w-100">
                                        <i class="bi bi-plus-circle"></i> 新規
                                    </button>
                                </div>
                                <div class="col-6">
                                    <button onclick="openDeleteDialog()" class="btn btn-danger btn-sm w-100">
                                        <i class="bi bi-trash"></i> 削除
                                    </button>
                                </div>
                            </div>
                        </div>

                        <!-- Undo/Redo -->
                        <div class="mb-3">
                            <h6 class="text-warning mb-2">編集</h6>
                            <div class="btn-group w-100" role="group">
                                <button onclick="undo()" class="btn btn-outline-light btn-sm" title="元に戻す (Ctrl+Z)">
                                    <i class="bi bi-arrow-counterclockwise"></i> アンドゥ
                                </button>
                                <button onclick="redo()" class="btn btn-outline-light btn-sm" title="やり直し (Ctrl+Y)">
                                    <i class="bi bi-arrow-clockwise"></i> リドゥ
                                </button>
                            </div>
                        </div>

                        <!-- Drawing Modes -->
                        <div class="mb-3">
                            <h6 class="text-warning mb-2">描画モード</h6>
                            <div class="btn-group w-100" role="group" aria-label="描画モード選択">
                                <input type="radio" class="btn-check" name="drawingMode" id="normalMode" value="normal"
                                    checked onchange="setDrawingMode()" autocomplete="off">
                                <label class="btn btn-outline-light btn-sm" for="normalMode" title="通常の単一セル描画モード (D)">
                                    <i class="bi bi-pencil"></i>
                                </label>

                                <input type="radio" class="btn-check" name="drawingMode" id="floodFillMode"
                                    value="floodFill" onchange="setDrawingMode()" autocomplete="off">
                                <label class="btn btn-outline-light btn-sm" for="floodFillMode"
                                    title="同じ地形の連続領域を一括で塗りつぶし (F)">
                                    <i class="bi bi-paint-bucket"></i>
                                </label>

                                <input type="radio" class="btn-check" name="drawingMode" id="rectangleMode"
                                    value="rectangle" onchange="setDrawingMode()" autocomplete="off">
                                <label class="btn btn-outline-light btn-sm" for="rectangleMode" title="矩形の枠線を描画 (R)">
                                    <i class="bi bi-square"></i>
                                </label>

                                <input type="radio" class="btn-check" name="drawingMode" id="filledRectangleMode"
                                    value="filledRectangle" onchange="setDrawingMode()" autocomplete="off">
                                <label class="btn btn-outline-light btn-sm" for="filledRectangleMode"
                                    title="矩形を塗りつぶして描画 (Shift+R)">
                                    <i class="bi bi-square-fill"></i>
                                </label>

                                <input type="radio" class="btn-check" name="drawingMode" id="circleMode" value="circle"
                                    onchange="setDrawingMode()" autocomplete="off">
                                <label class="btn btn-outline-light btn-sm" for="circleMode" title="円形・楕円の枠線を描画 (C)">
                                    <i class="bi bi-circle"></i>
                                </label>

                                <input type="radio" class="btn-check" name="drawingMode" id="filledCircleMode"
                                    value="filledCircle" onchange="setDrawingMode()" autocomplete="off">
                                <label class="btn btn-outline-light btn-sm" for="filledCircleMode"
                                    title="円形・楕円を塗りつぶして描画 (Shift+C)">
                                    <i class="bi bi-circle-fill"></i>
                                </label>
                            </div>
                        </div>

                        <!-- Slide Keys Controls -->
                        <div class="mb-3">
                            <h6 class="text-warning mb-2">操作</h6>
                            <div id="slide_keys"></div>
                        </div>

                        <!-- Tile Size -->
                        <div class="mb-3">
                            <h6 class="text-warning mb-2">表示設定</h6>
                            <label for="tile_size" class="form-label small">タイルサイズ</label>
                            <input type="number" class="form-control form-control-sm" id="tile_size" value="24" min="1"
                                max="100" step="1" onchange="updateTileSize()">
                        </div>
                    </div>
                </div>
            </div>

            <!-- Center - Canvas Area -->
            <div class="col-lg-6 col-md-8 col-12 order-1 order-md-2">
                <div class="card bg-secondary card-container">
                    <div class="card-header">
                        <h5 class="card-title mb-0">
                            <i class="bi bi-grid-3x3"></i> マップエディタ
                        </h5>
                    </div>
                    <div class="card-body p-2">
                        <div id="mappings" class="w-100">
                            <div id="tiles" class="overflow-auto border border-light rounded" style="max-height: 70vh;">
                            </div>
                            <div id="parse-error" class="mt-2"></div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Right Sidebar - Output -->
            <div class="col-lg-3 col-md-12 col-12 order-3">
                <div class="card bg-secondary card-container">
                    <div class="card-header d-flex justify-content-between align-items-center">
                        <h5 class="card-title mb-0">
                            <i class="bi bi-file-text"></i> 出力
                        </h5>
                        <button id="copy" onclick="copyToClipboard()" class="btn btn-success btn-sm">
                            <i class="bi bi-clipboard"></i> コピー
                        </button>
                    </div>
                    <div class="card-body p-2">
                        <textarea id="v_info" class="form-control h-100"
                            style="min-height: 400px; font-family: monospace; font-size: 12px;" readonly></textarea>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Modals -->
    <!-- Bootstrap Modal for Symbol Dialog -->
    <div class="modal fade" id="symbolModal" tabindex="-1" aria-labelledby="symbolModalLabel" aria-hidden="true">
        <div class="modal-dialog modal-lg">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="symbolModalLabel">新規地形定義</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <div class="mb-3">
                        <label for="symbolInput" class="form-label">地形シンボル (1文字):</label>
                        <input type="text" class="form-control" id="symbolInput" maxlength="1" style="width: 80px;">
                    </div>
                    <div class="mb-3">
                        <label for="actualTerrain" class="form-label">実際の地形:</label>
                        <div class="input-group mb-2">
                            <input type="text" class="form-control" id="actualTerrainFilter" placeholder="地形名で検索..."
                                onkeyup="filterActualTerrain()">
                            <button class="btn btn-outline-secondary" type="button"
                                onclick="clearActualTerrainFilter()">クリア</button>
                        </div>
                        <select class="form-select" id="actualTerrain" size="5">
                            <option value="">選択してください</option>
                        </select>
                    </div>
                    <div class="mb-3">
                        <label for="visualTerrain" class="form-label">見た目の地形:</label>
                        <div class="input-group mb-2">
                            <input type="text" class="form-control" id="visualTerrainFilter" placeholder="地形名で検索..."
                                onkeyup="filterVisualTerrain()">
                            <button class="btn btn-outline-secondary" type="button"
                                onclick="clearVisualTerrainFilter()">クリア</button>
                        </div>
                        <select class="form-select" id="visualTerrain" size="5">
                            <option value="">選択してください</option>
                        </select>
                    </div>
                    <div class="mb-3">
                        <label for="monsterSelect" class="form-label">配置モンスター (オプション):</label>
                        <div class="input-group mb-2">
                            <input type="text" class="form-control" id="monsterFilter" placeholder="モンスター名で検索..."
                                onkeyup="filterMonsters()">
                            <button class="btn btn-outline-secondary" type="button"
                                onclick="clearMonsterFilter()">クリア</button>
                        </div>
                        <select class="form-select" id="monsterSelect" size="5">
                            <option value="">なし</option>
                        </select>
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">キャンセル</button>
                    <button type="button" class="btn btn-primary" onclick="defineCustomTerrain()">定義</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Bootstrap Modal for Delete Dialog -->
    <div class="modal fade" id="deleteModal" tabindex="-1" aria-labelledby="deleteModalLabel" aria-hidden="true">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="deleteModalLabel">カスタム地形削除</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <div class="mb-3">
                        <label for="deleteTerrainSelect" class="form-label">削除する地形を選択:</label>
                        <select class="form-select" id="deleteTerrainSelect" size="8">
                        </select>
                    </div>
                    <div class="alert alert-warning" role="alert">
                        <i class="bi bi-exclamation-triangle"></i>
                        選択した地形は完全に削除されます。この操作は取り消せません。
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">キャンセル</button>
                    <button type="button" class="btn btn-danger" onclick="deleteCustomTerrain()">削除</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        function copyToClipboard() {
            var copyText = document.getElementById("v_info");
            copyText.select();
            copyText.setSelectionRange(0, 99999);
            document.execCommand("copy");
        }
    </script>

    <script>
        const VOID_TILE_COLOR = '#202020';
        const NORMAL_TILE_COLOR = '#000000';
        var touchmode = 'ontouchend' in document;

        // 地形定義データ
        let terrainDefinitions = [];
        let monsterDefinitions = []; // モンスター定義データ
        let customTerrains = {}; // カスタム地形の保存用

        // アンドゥ/リドゥ用の状態管理
        let undoStack = [];
        let redoStack = [];
        const MAX_UNDO_STEPS = 50; // 最大アンドゥ回数

        function update_texts() {
            let texts = document.getElementById('v_info');
            texts.value = `N:${mapID}:${mapName}\r\n`;
            texts.value += `X:${mapType}:8:${mapHeight}:${mapWidth}\r\n`;

            // カスタム地形定義を出力
            for (let symbol in customTerrains) {
                const terrain = customTerrains[symbol];
                let line = `F:${symbol}:${terrain.actual}:${terrain.visual}`;

                // モンスターが設定されている場合は:MONSTER_IDを追加
                if (terrain.monster) {
                    line += `:MONSTER_${terrain.monster}`;
                }

                texts.value += line + '\r\n';
            }

            for (let j = 0; j < mapHeight; j++) {
                texts.value += 'D:';
                for (let i = 0; i < mapWidth; i++) {
                    texts.value += grid[i][j];
                }
                texts.value += '\r\n';
            }
        }

        // 現在の状態を保存する関数
        function saveState() {
            const state = {
                grid: grid.map(row => [...row]), // ディープコピー
                mapWidth: mapWidth,
                mapHeight: mapHeight,
                mapName: mapName,
                mapID: mapID,
                mapType: mapType,
                customTerrains: JSON.parse(JSON.stringify(customTerrains)) // ディープコピー
            };

            undoStack.push(state);

            // スタックサイズを制限
            if (undoStack.length > MAX_UNDO_STEPS) {
                undoStack.shift();
            }

            // 新しい操作が行われたのでリドゥスタックをクリア
            redoStack = [];
        }

        // 状態を復元する関数
        function restoreState(state) {
            grid = state.grid.map(row => [...row]); // ディープコピー
            mapWidth = state.mapWidth;
            mapHeight = state.mapHeight;
            mapName = state.mapName;
            mapID = state.mapID;
            mapType = state.mapType;
            customTerrains = JSON.parse(JSON.stringify(state.customTerrains)); // ディープコピー

            // UI要素を更新
            document.getElementById('vault-width').value = mapWidth;
            document.getElementById('vault-height').value = mapHeight;
            document.getElementById('vault-name').value = mapName;
            document.getElementById('vault-id').value = mapID;
            document.getElementById('vault-type').value = mapType;

            // カスタム地形のセレクトボックスを再構築
            rebuildCustomTerrainOptions();

            // グリッドとテキストを更新
            drawGrid();
            update_texts();
        }

        // カスタム地形のセレクトボックスを再構築する関数
        function rebuildCustomTerrainOptions() {
            const gridTypeSelect = document.getElementById('grid_type');

            // 既存のカスタム地形オプションを削除
            const options = Array.from(gridTypeSelect.options);
            options.forEach(option => {
                // デフォルトの地形以外（カスタム地形）を削除
                if (!isDefaultTerrain(option.value)) {
                    gridTypeSelect.removeChild(option);
                }
            });

            // カスタム地形を再追加
            for (let symbol in customTerrains) {
                addSymbolToMainSelect(symbol);
            }
        }

        // デフォルト地形かどうかを判定する関数
        function isDefaultTerrain(symbol) {
            const defaultSymbols = ['.', ' ', '%', '#', '$', 'X', 'Y', '*', '+', '-', "'", '^', '&', '@', '9', '8', ',', ':', '[', '~', '=', 'v', 'w', 'f', 'F', 'g', 'G', 'h', 'H', 'i', 'I'];
            return defaultSymbols.includes(symbol);
        }

        // アンドゥ機能
        function undo() {
            if (undoStack.length === 0) {
                showToast('アンドゥできる操作がありません', 'info');
                return;
            }

            // 現在の状態をリドゥスタックに保存
            const currentState = {
                grid: grid.map(row => [...row]),
                mapWidth: mapWidth,
                mapHeight: mapHeight,
                mapName: mapName,
                mapID: mapID,
                mapType: mapType,
                customTerrains: JSON.parse(JSON.stringify(customTerrains))
            };
            redoStack.push(currentState);

            // 前の状態を復元
            const previousState = undoStack.pop();
            restoreState(previousState);

            showToast('操作を元に戻しました', 'success');
        }

        // リドゥ機能
        function redo() {
            if (redoStack.length === 0) {
                showToast('リドゥできる操作がありません', 'info');
                return;
            }

            // 現在の状態をアンドゥスタックに保存
            const currentState = {
                grid: grid.map(row => [...row]),
                mapWidth: mapWidth,
                mapHeight: mapHeight,
                mapName: mapName,
                mapID: mapID,
                mapType: mapType,
                customTerrains: JSON.parse(JSON.stringify(customTerrains))
            };
            undoStack.push(currentState);

            // 次の状態を復元
            const nextState = redoStack.pop();
            restoreState(nextState);

            showToast('操作をやり直しました', 'success');
        }

        // フラッドフィル（塗りつぶし）機能
        function floodFill(startX, startY, newTerrain) {
            const originalTerrain = grid[startX][startY];

            // 同じ地形の場合は何もしない
            if (originalTerrain === newTerrain) {
                return false;
            }

            // 状態を保存
            saveState();

            // BFS（幅優先探索）を使用してフラッドフィル
            const queue = [[startX, startY]];
            const visited = Array.from({ length: mapWidth }, () => Array(mapHeight).fill(false));

            while (queue.length > 0) {
                const [x, y] = queue.shift();

                // 範囲外または既に訪問済みの場合はスキップ
                if (x < 0 || x >= mapWidth || y < 0 || y >= mapHeight || visited[x][y]) {
                    continue;
                }

                // 異なる地形の場合はスキップ
                if (grid[x][y] !== originalTerrain) {
                    continue;
                }

                // 地形を変更し、訪問済みにマーク
                grid[x][y] = newTerrain;
                visited[x][y] = true;

                // 隣接する4方向を探索キューに追加
                queue.push([x + 1, y]);
                queue.push([x - 1, y]);
                queue.push([x, y + 1]);
                queue.push([x, y - 1]);
            }

            // グリッドとテキストを更新
            drawGrid();
            update_texts();

            return true;
        }

        // フラッドフィルモードの状態管理
        let isFloodFillMode = false;
        let isRectangleMode = false;
        let isFilledRectangleMode = false;
        let isCircleMode = false;
        let isFilledCircleMode = false;

        // 矩形描画用の変数
        let isDrawingRectangle = false;
        let rectangleStartX = -1;
        let rectangleStartY = -1;
        let rectangleEndX = -1;
        let rectangleEndY = -1;
        let previewRectangle = null;

        // 円形描画用の変数
        let isDrawingCircle = false;
        let circleStartX = -1;
        let circleStartY = -1;
        let circleEndX = -1;
        let circleEndY = -1;
        let previewCircle = null;

        // Konvaのグローバル変数
        let globalStage = null;
        let globalLayer = null;

        // 描画モードの設定（ラジオボタン用）
        function setDrawingMode() {
            const normalMode = document.getElementById('normalMode');
            const floodFillMode = document.getElementById('floodFillMode');
            const rectangleMode = document.getElementById('rectangleMode');
            const filledRectangleMode = document.getElementById('filledRectangleMode');
            const circleMode = document.getElementById('circleMode');
            const filledCircleMode = document.getElementById('filledCircleMode');

            // プレビューをクリア
            clearPreview();

            // 矩形描画状態をリセット
            isDrawingRectangle = false;
            rectangleStartX = -1;
            rectangleStartY = -1;
            rectangleEndX = -1;
            rectangleEndY = -1;

            // 円形描画状態をリセット
            isDrawingCircle = false;
            circleStartX = -1;
            circleStartY = -1;
            circleEndX = -1;
            circleEndY = -1;

            // 全てのモードをリセット
            isFloodFillMode = false;
            isRectangleMode = false;
            isFilledRectangleMode = false;
            isCircleMode = false;
            isFilledCircleMode = false;

            if (normalMode.checked) {
                showToast('通常描画モードに切り替えました', 'info');
            } else if (floodFillMode.checked) {
                isFloodFillMode = true;
                showToast('塗りつぶしモードに切り替えました: 地形をクリックして塗りつぶしてください', 'info');
            } else if (rectangleMode.checked) {
                isRectangleMode = true;
                showToast('矩形描画モードに切り替えました: ドラッグして矩形の枠線を描画してください', 'info');
            } else if (filledRectangleMode.checked) {
                isFilledRectangleMode = true;
                showToast('塗りつぶし矩形モードに切り替えました: ドラッグして矩形を塗りつぶしてください', 'info');
            } else if (circleMode.checked) {
                isCircleMode = true;
                showToast('円形・楕円描画モードに切り替えました: ドラッグして円形・楕円の枠線を描画してください', 'info');
            } else if (filledCircleMode.checked) {
                isFilledCircleMode = true;
                showToast('塗りつぶし円形・楕円モードに切り替えました: ドラッグして円形・楕円を塗りつぶしてください', 'info');
            }
        }

        // 旧関数（後方互換性のため残す）
        function toggleFloodFillMode() {
            const normalMode = document.getElementById('normalMode');
            const floodFillMode = document.getElementById('floodFillMode');

            if (isFloodFillMode) {
                normalMode.checked = true;
            } else {
                floodFillMode.checked = true;
            }
            setDrawingMode();
        }
        let mouseDown = false
        let currentTerrain = ".";

        if (touchmode) {
            document.body.ontouchstart = function () {
                mouseDown = true;
            }
            document.body.ontouchend = function () {
                mouseDown = false;
            }
        }
        else {
            document.body.onmousedown = function () {
                mouseDown = true;
            }
            document.body.onmouseup = function () {
                mouseDown = false;
            }
        }


        document.getElementById('grid_type').onchange = function () {
            currentTerrain = this.value;
        }

        // 矩形描画関数
        function drawRectangle() {
            if (rectangleStartX === -1 || rectangleStartY === -1) return;

            // プレビューをクリア
            clearPreview();

            saveState();

            const minX = Math.min(rectangleStartX, rectangleEndX);
            const maxX = Math.max(rectangleStartX, rectangleEndX);
            const minY = Math.min(rectangleStartY, rectangleEndY);
            const maxY = Math.max(rectangleStartY, rectangleEndY);

            if (isFilledRectangleMode) {
                // 塗りつぶし矩形
                for (let x = minX; x <= maxX; x++) {
                    for (let y = minY; y <= maxY; y++) {
                        if (x < mapWidth && y < mapHeight) {
                            grid[x][y] = currentTerrain;
                        }
                    }
                }
                showToast(`塗りつぶし矩形を描画しました (${maxX - minX + 1}×${maxY - minY + 1})`, 'success');
            } else {
                // 矩形の枠線のみ
                for (let x = minX; x <= maxX; x++) {
                    if (x < mapWidth) {
                        if (minY < mapHeight) grid[x][minY] = currentTerrain; // 上辺
                        if (maxY < mapHeight) grid[x][maxY] = currentTerrain; // 下辺
                    }
                }
                for (let y = minY; y <= maxY; y++) {
                    if (y < mapHeight) {
                        if (minX < mapWidth) grid[minX][y] = currentTerrain; // 左辺
                        if (maxX < mapWidth) grid[maxX][y] = currentTerrain; // 右辺
                    }
                }
                showToast(`矩形の枠線を描画しました (${maxX - minX + 1}×${maxY - minY + 1})`, 'success');
            }

            update_texts();
            drawGrid();
        }

        // 円形・楕円描画関数
        function drawCircle() {
            if (circleStartX === -1 || circleStartY === -1) return;

            // プレビューをクリア
            clearPreview();

            saveState();

            const centerX = circleStartX;
            const centerY = circleStartY;
            const radiusX = Math.abs(circleEndX - circleStartX);
            const radiusY = Math.abs(circleEndY - circleStartY);

            if (isFilledCircleMode) {
                // 塗りつぶし円形・楕円
                const points = getFilledEllipsePoints(centerX, centerY, radiusX, radiusY);
                points.forEach(([x, y]) => {
                    if (x >= 0 && x < mapWidth && y >= 0 && y < mapHeight) {
                        grid[x][y] = currentTerrain;
                    }
                });
                const shapeType = radiusX === radiusY ? '円形' : '楕円';
                showToast(`塗りつぶし${shapeType}を描画しました (半径: ${radiusX}×${radiusY})`, 'success');
            } else {
                // 円形・楕円の枠線のみ
                const points = getEllipsePoints(centerX, centerY, radiusX, radiusY);
                points.forEach(([x, y]) => {
                    if (x >= 0 && x < mapWidth && y >= 0 && y < mapHeight) {
                        grid[x][y] = currentTerrain;
                    }
                });
                const shapeType = radiusX === radiusY ? '円形' : '楕円';
                showToast(`${shapeType}の枠線を描画しました (半径: ${radiusX}×${radiusY})`, 'success');
            }

            update_texts();
            drawGrid();
        }

        // 楕円周上の点を取得する関数（修正ミッドポイント楕円アルゴリズム）
        function getEllipsePoints(centerX, centerY, radiusX, radiusY) {
            const points = [];

            // 円の場合は従来のアルゴリズムを使用
            if (radiusX === radiusY) {
                return getCirclePoints(centerX, centerY, radiusX);
            }

            // 楕円の場合
            if (radiusX === 0 && radiusY === 0) {
                points.push([centerX, centerY]);
                return points;
            }

            if (radiusX === 0) {
                // 垂直線
                for (let y = -radiusY; y <= radiusY; y++) {
                    points.push([centerX, centerY + y]);
                }
                return points;
            }

            if (radiusY === 0) {
                // 水平線
                for (let x = -radiusX; x <= radiusX; x++) {
                    points.push([centerX + x, centerY]);
                }
                return points;
            }

            // 楕円アルゴリズム（領域1）
            let x = 0;
            let y = radiusY;
            let dx = 2 * radiusY * radiusY * x;
            let dy = 2 * radiusX * radiusX * y;
            let err = radiusY * radiusY - radiusX * radiusX * radiusY + radiusX * radiusX / 4;

            while (dx < dy) {
                // 4象限の点を追加
                points.push([centerX + x, centerY + y]);
                points.push([centerX - x, centerY + y]);
                points.push([centerX + x, centerY - y]);
                points.push([centerX - x, centerY - y]);

                if (err < 0) {
                    x++;
                    dx += 2 * radiusY * radiusY;
                    err += dx + radiusY * radiusY;
                } else {
                    x++;
                    y--;
                    dx += 2 * radiusY * radiusY;
                    dy -= 2 * radiusX * radiusX;
                    err += dx - dy + radiusY * radiusY;
                }
            }

            // 楕円アルゴリズム（領域2）
            err = radiusY * radiusY * (x + 0.5) * (x + 0.5) + radiusX * radiusX * (y - 1) * (y - 1) - radiusX * radiusX * radiusY * radiusY;

            while (y >= 0) {
                // 4象限の点を追加
                points.push([centerX + x, centerY + y]);
                points.push([centerX - x, centerY + y]);
                points.push([centerX + x, centerY - y]);
                points.push([centerX - x, centerY - y]);

                if (err > 0) {
                    y--;
                    dy -= 2 * radiusX * radiusX;
                    err += radiusX * radiusX - dy;
                } else {
                    y--;
                    x++;
                    dx += 2 * radiusY * radiusY;
                    dy -= 2 * radiusX * radiusX;
                    err += dx - dy + radiusX * radiusX;
                }
            }

            // 重複を除去
            const uniquePoints = [];
            const pointSet = new Set();
            points.forEach(([x, y]) => {
                const key = `${x},${y}`;
                if (!pointSet.has(key)) {
                    pointSet.add(key);
                    uniquePoints.push([x, y]);
                }
            });

            return uniquePoints;
        }

        // 円周上の点を取得する関数（ブレゼンハムの円描画アルゴリズム）
        function getCirclePoints(centerX, centerY, radius) {
            const points = [];
            if (radius === 0) {
                points.push([centerX, centerY]);
                return points;
            }

            let x = 0;
            let y = radius;
            let d = 3 - 2 * radius;

            while (x <= y) {
                // 8方向の対称点を追加
                points.push([centerX + x, centerY + y]);
                points.push([centerX - x, centerY + y]);
                points.push([centerX + x, centerY - y]);
                points.push([centerX - x, centerY - y]);
                points.push([centerX + y, centerY + x]);
                points.push([centerX - y, centerY + x]);
                points.push([centerX + y, centerY - x]);
                points.push([centerX - y, centerY - x]);

                if (d < 0) {
                    d = d + 4 * x + 6;
                } else {
                    d = d + 4 * (x - y) + 10;
                    y--;
                }
                x++;
            }

            // 重複を除去
            const uniquePoints = [];
            const pointSet = new Set();
            points.forEach(([x, y]) => {
                const key = `${x},${y}`;
                if (!pointSet.has(key)) {
                    pointSet.add(key);
                    uniquePoints.push([x, y]);
                }
            });

            return uniquePoints;
        }

        // 塗りつぶし楕円の点を取得する関数
        function getFilledEllipsePoints(centerX, centerY, radiusX, radiusY) {
            const points = [];

            // 円の場合は従来のアルゴリズムを使用
            if (radiusX === radiusY) {
                return getFilledCirclePoints(centerX, centerY, radiusX);
            }

            // 楕円の内部を塗りつぶし
            for (let x = centerX - radiusX; x <= centerX + radiusX; x++) {
                for (let y = centerY - radiusY; y <= centerY + radiusY; y++) {
                    // 楕円の方程式: (x-h)^2/a^2 + (y-k)^2/b^2 <= 1
                    const normalizedX = (x - centerX);
                    const normalizedY = (y - centerY);

                    if (radiusX === 0 && radiusY === 0) {
                        if (x === centerX && y === centerY) {
                            points.push([x, y]);
                        }
                    } else if (radiusX === 0) {
                        if (x === centerX && Math.abs(normalizedY) <= radiusY) {
                            points.push([x, y]);
                        }
                    } else if (radiusY === 0) {
                        if (y === centerY && Math.abs(normalizedX) <= radiusX) {
                            points.push([x, y]);
                        }
                    } else {
                        const ellipseValue = (normalizedX * normalizedX) / (radiusX * radiusX) +
                            (normalizedY * normalizedY) / (radiusY * radiusY);
                        if (ellipseValue <= 1.0) {
                            points.push([x, y]);
                        }
                    }
                }
            }

            return points;
        }

        // 塗りつぶし円形の点を取得する関数
        function getFilledCirclePoints(centerX, centerY, radius) {
            const points = [];

            for (let x = centerX - radius; x <= centerX + radius; x++) {
                for (let y = centerY - radius; y <= centerY + radius; y++) {
                    const distance = Math.sqrt((x - centerX) ** 2 + (y - centerY) ** 2);
                    if (distance <= radius) {
                        points.push([x, y]);
                    }
                }
            }

            return points;
        }

        // プレビュー矩形を描画する関数
        function drawPreviewRectangle() {
            if (rectangleStartX === -1 || rectangleStartY === -1 || !globalStage || !globalLayer) return;

            const minX = Math.min(rectangleStartX, rectangleEndX);
            const maxX = Math.max(rectangleStartX, rectangleEndX);
            const minY = Math.min(rectangleStartY, rectangleEndY);
            const maxY = Math.max(rectangleStartY, rectangleEndY);

            // 既存のプレビュー要素を削除
            const existingPreview = globalLayer.findOne('.preview-rectangle');
            if (existingPreview) {
                existingPreview.destroy();
            }

            // プレビューグループを作成
            const previewGroup = new Konva.Group({
                name: 'preview-rectangle'
            });

            // 範囲内の各セルを色反転で表示
            for (let x = minX; x <= maxX; x++) {
                for (let y = minY; y <= maxY; y++) {
                    if (x < mapWidth && y < mapHeight) {
                        // 色反転エフェクト用の矩形
                        const invertRect = new Konva.Rect({
                            x: x * gridSize,
                            y: y * gridSize,
                            width: gridSize,
                            height: gridSize,
                            fill: '#ffffff',
                            opacity: 0.4,
                            globalCompositeOperation: 'difference'
                        });
                        previewGroup.add(invertRect);

                        // 塗りつぶしモードの場合は追加の色付けエフェクト
                        if (isFilledRectangleMode) {
                            const fillPreview = new Konva.Rect({
                                x: x * gridSize,
                                y: y * gridSize,
                                width: gridSize,
                                height: gridSize,
                                fill: '#ffff00', // 黄色でプレビュー
                                opacity: 0.3
                            });
                            previewGroup.add(fillPreview);
                        }

                        // 境界線の描画
                        const shouldDrawBorder =
                            (isFilledRectangleMode) ||
                            (x === minX || x === maxX || y === minY || y === maxY);

                        if (shouldDrawBorder) {
                            const borderRect = new Konva.Rect({
                                x: x * gridSize,
                                y: y * gridSize,
                                width: gridSize,
                                height: gridSize,
                                stroke: isFilledRectangleMode ? '#ff6600' : '#ff0000', // 塗りつぶしはオレンジ、枠線は赤
                                strokeWidth: 2,
                                fill: 'transparent'
                            });
                            previewGroup.add(borderRect);
                        }
                    }
                }
            }

            // 点線の外枠を追加（塗りつぶしモードは太い線）
            const dashedBorder = new Konva.Rect({
                x: minX * gridSize - 1,
                y: minY * gridSize - 1,
                width: (maxX - minX + 1) * gridSize + 2,
                height: (maxY - minY + 1) * gridSize + 2,
                stroke: isFilledRectangleMode ? '#ff6600' : '#ff4444', // 塗りつぶしはオレンジ、枠線は赤
                strokeWidth: isFilledRectangleMode ? 4 : 3, // 塗りつぶしは太い線
                dash: isFilledRectangleMode ? [6, 3] : [8, 4], // 塗りつぶしは短い点線
                fill: 'transparent'
            });
            previewGroup.add(dashedBorder);

            // プレビューをレイヤーに追加
            globalLayer.add(previewGroup);
            globalLayer.draw();
        }

        // プレビュー円形・楕円を描画する関数
        function drawPreviewCircle() {
            if (circleStartX === -1 || circleStartY === -1 || !globalStage || !globalLayer) return;

            const centerX = circleStartX;
            const centerY = circleStartY;
            const radiusX = Math.abs(circleEndX - circleStartX);
            const radiusY = Math.abs(circleEndY - circleStartY);

            // 既存のプレビュー要素を削除
            const existingPreview = globalLayer.findOne('.preview-circle');
            if (existingPreview) {
                existingPreview.destroy();
            }

            // プレビューグループを作成
            const previewGroup = new Konva.Group({
                name: 'preview-circle'
            });

            // 円形・楕円の点を取得
            const points = isFilledCircleMode ?
                getFilledEllipsePoints(centerX, centerY, radiusX, radiusY) :
                getEllipsePoints(centerX, centerY, radiusX, radiusY);

            // 各点を色反転で表示
            points.forEach(([x, y]) => {
                if (x >= 0 && x < mapWidth && y >= 0 && y < mapHeight) {
                    // 色反転エフェクト用の矩形
                    const invertRect = new Konva.Rect({
                        x: x * gridSize,
                        y: y * gridSize,
                        width: gridSize,
                        height: gridSize,
                        fill: '#ffffff',
                        opacity: 0.4,
                        globalCompositeOperation: 'difference'
                    });
                    previewGroup.add(invertRect);

                    // 塗りつぶしモードの場合は追加の色付けエフェクト
                    if (isFilledCircleMode) {
                        const fillPreview = new Konva.Rect({
                            x: x * gridSize,
                            y: y * gridSize,
                            width: gridSize,
                            height: gridSize,
                            fill: '#00ff00', // 緑色でプレビュー
                            opacity: 0.3
                        });
                        previewGroup.add(fillPreview);
                    }

                    // 境界線の描画
                    const borderRect = new Konva.Rect({
                        x: x * gridSize,
                        y: y * gridSize,
                        width: gridSize,
                        height: gridSize,
                        stroke: isFilledCircleMode ? '#00aa00' : '#0000ff', // 塗りつぶしは緑、枠線は青
                        strokeWidth: 2,
                        fill: 'transparent'
                    });
                    previewGroup.add(borderRect);
                }
            });

            // 楕円の外枠を追加
            if (radiusX === radiusY) {
                // 円の場合
                const circleOutline = new Konva.Circle({
                    x: centerX * gridSize + gridSize / 2,
                    y: centerY * gridSize + gridSize / 2,
                    radius: radiusX * gridSize + gridSize / 2,
                    stroke: isFilledCircleMode ? '#00aa00' : '#4444ff',
                    strokeWidth: isFilledCircleMode ? 4 : 3,
                    dash: isFilledCircleMode ? [6, 3] : [8, 4],
                    fill: 'transparent'
                });
                previewGroup.add(circleOutline);
            } else {
                // 楕円の場合
                const ellipseOutline = new Konva.Ellipse({
                    x: centerX * gridSize + gridSize / 2,
                    y: centerY * gridSize + gridSize / 2,
                    radiusX: radiusX * gridSize + gridSize / 2,
                    radiusY: radiusY * gridSize + gridSize / 2,
                    stroke: isFilledCircleMode ? '#00aa00' : '#4444ff',
                    strokeWidth: isFilledCircleMode ? 4 : 3,
                    dash: isFilledCircleMode ? [6, 3] : [8, 4],
                    fill: 'transparent'
                });
                previewGroup.add(ellipseOutline);
            }

            // プレビューをレイヤーに追加
            globalLayer.add(previewGroup);
            globalLayer.draw();
        }

        // プレビューをクリアする関数
        function clearPreview() {
            if (!globalLayer) return;

            // 矩形プレビュー要素を削除
            const existingRectPreview = globalLayer.findOne('.preview-rectangle');
            if (existingRectPreview) {
                existingRectPreview.destroy();
            }

            // 円形プレビュー要素を削除
            const existingCirclePreview = globalLayer.findOne('.preview-circle');
            if (existingCirclePreview) {
                existingCirclePreview.destroy();
            }

            globalLayer.draw();
        }

        // グリッドサイズとマップサイズ
        let gridSize = 24; // タイルサイズ

        // タイルサイズの変更
        function updateTileSize() {
            const newSize = document.getElementById('tile_size').value;
            if (newSize > 0) {
                gridSize = newSize;
                drawGrid();
            }
        }

        let mapWidth = document.getElementById('vault-width').value;
        let mapHeight = document.getElementById('vault-height').value;
        let mapName = document.getElementById('vault-name').value;
        let mapID = document.getElementById('vault-id').value;
        let mapType = document.getElementById('vault-type').value;

        document.getElementById('vault-width').onchange = function () {
            saveState();
            mapWidth = document.getElementById('vault-width').value;
            drawGrid();
            update_texts();
        }

        document.getElementById('vault-height').onchange = function () {
            saveState();
            mapHeight = document.getElementById('vault-height').value;
            drawGrid();
            update_texts();
        }

        document.getElementById('vault-id').onchange = function () {
            mapID = document.getElementById('vault-id').value;
            update_texts();
        }

        document.getElementById('vault-type').onchange = function () {
            mapType = document.getElementById('vault-type').value;
            update_texts();
        }

        document.getElementById('vault-name').onchange = function () {
            mapName = document.getElementById('vault-name').value;
            update_texts();
        }

        const MapMaxSize = 300;
        let grid = Array.from({ length: MapMaxSize }, () => Array(MapMaxSize).fill(" "));
        let konva_text = Array.from({ length: MapMaxSize }, () => Array(MapMaxSize).fill(null));

        // グリッドを描画する関数
        function drawGrid() {
            // 既存のステージをクリア
            const tilesContainer = document.getElementById('tiles');
            tilesContainer.innerHTML = '';

            globalStage = new Konva.Stage({
                container: 'tiles',
                width: gridSize * mapWidth,
                height: gridSize * mapHeight
            });

            globalLayer = new Konva.Layer();
            konva_text = Array.from({ length: MapMaxSize }, () => Array(MapMaxSize).fill(null));
            globalStage.add(globalLayer);
            for (let i = 0; i < mapWidth; i++) {
                for (let j = 0; j < mapHeight; j++) {
                    const rect = new Konva.Rect({
                        x: i * gridSize,
                        y: j * gridSize,
                        width: gridSize,
                        height: gridSize,
                        fill: grid[i][j] === " " ? VOID_TILE_COLOR : NORMAL_TILE_COLOR,
                        stroke: 'white',
                        strokeWidth: 1
                    });

                    rect.on('mousedown', function () {
                        if (isFloodFillMode) {
                            // フラッドフィルモードの場合
                            const filled = floodFill(i, j, currentTerrain);
                            if (filled) {
                                showToast(`地形 "${grid[i][j]}" を "${currentTerrain}" で塗りつぶしました`, 'success');
                            }
                        } else if (isRectangleMode || isFilledRectangleMode) {
                            // 矩形描画モードの場合
                            if (!isDrawingRectangle) {
                                isDrawingRectangle = true;
                                rectangleStartX = i;
                                rectangleStartY = j;
                                rectangleEndX = i;
                                rectangleEndY = j;
                            }
                        } else if (isCircleMode || isFilledCircleMode) {
                            // 円形描画モードの場合
                            if (!isDrawingCircle) {
                                isDrawingCircle = true;
                                circleStartX = i;
                                circleStartY = j;
                                circleEndX = i;
                                circleEndY = j;
                            }
                        } else {
                            // 通常モードの場合
                            saveState();
                            grid[i][j] = currentTerrain;
                            update_texts();
                            drawGrid();
                        }
                    });

                    konva_text[i][j] = new Konva.Text({
                        x: i * gridSize + 1,
                        y: j * gridSize + 1,
                        text: grid[i][j],
                        fontSize: gridSize,
                        fontFamily: 'Arial',
                        stroke: 'white',
                        listening: false,
                    });

                    gridUpdate = function () {
                        if (isRectangleMode || isFilledRectangleMode) {
                            // 矩形描画モードの場合
                            if (isDrawingRectangle) {
                                rectangleEndX = i;
                                rectangleEndY = j;
                                drawPreviewRectangle();
                            }
                        } else if (isCircleMode || isFilledCircleMode) {
                            // 円形描画モードの場合
                            if (isDrawingCircle) {
                                circleEndX = i;
                                circleEndY = j;
                                drawPreviewCircle();
                            }
                        } else {
                            // 描画モード以外の場合はプレビューをクリア
                            clearPreview();

                            if (mouseDown && !isFloodFillMode) {
                                grid[i][j] = currentTerrain;
                                this.fill(grid[i][j] === " " ? VOID_TILE_COLOR : NORMAL_TILE_COLOR);
                                konva_text[i][j].text(grid[i][j]);
                                globalLayer.draw();
                                update_texts();
                            }
                        }
                    };

                    if (touchmode) {
                        rect.on('touchmove', gridUpdate);
                    }
                    else {
                        rect.on('mousemove', gridUpdate);
                    }

                    globalLayer.add(rect);
                    globalLayer.add(konva_text[i][j]);
                }
            }
            globalLayer.draw();

            // 矩形・円形描画用のステージイベントハンドラー
            globalStage.on('mouseup', function () {
                if ((isRectangleMode || isFilledRectangleMode) && isDrawingRectangle) {
                    isDrawingRectangle = false;
                    drawRectangle();
                    clearPreview();
                } else if ((isCircleMode || isFilledCircleMode) && isDrawingCircle) {
                    isDrawingCircle = false;
                    drawCircle();
                    clearPreview();
                }
            });
        }
        window.onload = function () {
            loadTerrainDefinitions();
            drawGrid();
            update_texts();
        };

        function openDialog() {
            if (terrainDefinitions.length === 0) {
                alert('地形定義データを読み込み中です。しばらくお待ちください。');
                return;
            }
            updateSymbolDialog();
            // Bootstrapモーダルを表示
            const modal = new bootstrap.Modal(document.getElementById('symbolModal'));
            modal.show();
        }

        function openDeleteDialog() {
            updateDeleteDialog();
            // Bootstrapモーダルを表示
            const modal = new bootstrap.Modal(document.getElementById('deleteModal'));
            modal.show();
        }

        function updateDeleteDialog() {
            const deleteSelect = document.getElementById('deleteTerrainSelect');
            deleteSelect.innerHTML = '';

            // カスタム地形がない場合のメッセージ
            if (Object.keys(customTerrains).length === 0) {
                const option = document.createElement('option');
                option.value = '';
                option.textContent = '削除可能なカスタム地形がありません';
                option.disabled = true;
                deleteSelect.appendChild(option);
                return;
            }

            // カスタム地形のみを表示
            for (let symbol in customTerrains) {
                const terrain = customTerrains[symbol];
                const actualTerrainInfo = terrainDefinitions.find(t => t.id == terrain.actual);
                const visualTerrainInfo = terrainDefinitions.find(t => t.id == terrain.visual);

                const actualName = actualTerrainInfo ? (actualTerrainInfo.japaneName || actualTerrainInfo.englishName || actualTerrainInfo.name) : 'Unknown';
                const visualName = visualTerrainInfo ? (visualTerrainInfo.japaneName || visualTerrainInfo.englishName || visualTerrainInfo.name) : 'Unknown';

                let description = `実際: ${actualName}, 見た目: ${visualName}`;

                if (terrain.monster) {
                    const monsterInfo = monsterDefinitions.find(m => m.id == terrain.monster);
                    if (monsterInfo) {
                        const jaName = monsterInfo.name?.ja || monsterInfo.japaneName || '';
                        const enName = monsterInfo.name?.en || monsterInfo.englishName || monsterInfo.name || '';
                        const monsterName = jaName || enName || 'Unknown Monster';
                        description += `, モンスター: ${monsterName}`;
                    }
                }

                const option = document.createElement('option');
                option.value = symbol;
                option.textContent = `${symbol} - ${description}`;
                deleteSelect.appendChild(option);
            }
        }

        function deleteCustomTerrain() {
            const deleteSelect = document.getElementById('deleteTerrainSelect');
            const selectedSymbol = deleteSelect.value;

            if (!selectedSymbol) {
                alert('削除する地形を選択してください');
                return;
            }

            // 確認ダイアログ
            if (!confirm(`地形 "${selectedSymbol}" を削除しますか？この操作は取り消せません。`)) {
                return;
            }

            // 状態を保存
            saveState();

            // マップ上の削除対象地形をスペースに置き換え
            for (let i = 0; i < mapWidth; i++) {
                for (let j = 0; j < mapHeight; j++) {
                    if (grid[i][j] === selectedSymbol) {
                        grid[i][j] = ' ';
                    }
                }
            }

            // カスタム地形から削除
            delete customTerrains[selectedSymbol];

            // メインセレクトボックスからも削除
            const gridTypeSelect = document.getElementById('grid_type');
            const options = gridTypeSelect.options;
            for (let i = options.length - 1; i >= 0; i--) {
                if (options[i].value === selectedSymbol) {
                    gridTypeSelect.removeChild(options[i]);
                    break;
                }
            }

            // 現在選択中の地形が削除された地形だった場合、デフォルトに変更
            if (currentTerrain === selectedSymbol) {
                currentTerrain = '.';
                gridTypeSelect.value = '.';
            }

            // グリッドを再描画
            drawGrid();

            // 削除ダイアログを更新
            updateDeleteDialog();

            // テキストを更新
            update_texts();

            // モーダルを閉じる
            const modal = bootstrap.Modal.getInstance(document.getElementById('deleteModal'));
            if (modal) {
                modal.hide();
            }

            // 成功メッセージを表示
            showToast(`地形 "${selectedSymbol}" が削除されました。マップ上の該当地形はスペースに置き換えられました。`, 'success');
        }

        function closeDialog() {
            // Bootstrapモーダルを非表示
            const modal = bootstrap.Modal.getInstance(document.getElementById('symbolModal'));
            if (modal) {
                modal.hide();
            }
        }

        function addSymbolToSelect(symbol) {
            let selectBox = document.querySelector('select');
            let option = document.createElement('option');
            option.value = symbol;
            option.text = `${symbol} - 新規地形`;
            selectBox.add(option);
        }

        function defineSymbol() {
            let newSymbol = document.getElementById('symbolInput').value;
            if (newSymbol.length === 1) {
                currentTerrain = newSymbol;
                addSymbolToSelect(newSymbol);
                closeDialog();
            }
        }

        // TerrainDefinitions.txtから地形データを取得
        function loadTerrainDefinitions() {
            fetch('https://raw.githubusercontent.com/deskull-m/bakabakaband/refs/heads/master/lib/edit/TerrainDefinitions.txt')
                .then(response => response.text())
                .then(text => {
                    const lines = text.split('\n');
                    let currentTerrain = {};

                    for (let line of lines) {
                        line = line.trim();
                        if (line.startsWith('N:')) {
                            // 前の地形があれば保存
                            if (currentTerrain.id !== undefined) {
                                terrainDefinitions.push({ ...currentTerrain });
                            }
                            // 新しい地形の開始
                            const match = line.match(/N:(\d+):(.+)/);
                            if (match) {
                                currentTerrain = {
                                    id: parseInt(match[1]),
                                    name: match[2]
                                };
                            }
                            if (!currentTerrain.tags) {
                                currentTerrain.tags = [];
                            }
                            currentTerrain.tags.push(currentTerrain.name);
                        } else if (line.startsWith('J:')) {
                            currentTerrain.japaneName = line.substring(2);
                        } else if (line.startsWith('E:')) {
                            currentTerrain.englishName = line.substring(2);
                        }
                    }

                    // 最後の地形も保存
                    if (currentTerrain.id !== undefined) {
                        terrainDefinitions.push(currentTerrain);
                    }

                    console.log('地形定義データを読み込みました:', terrainDefinitions.length, '件');

                    // モンスターデータも読み込み
                    loadMonsterDefinitions();
                })
                .catch(error => {
                    console.error('地形定義データの読み込みに失敗しました:', error);
                });
        }

        // MonraceDefinitions.jsoncからモンスターデータを取得
        function loadMonsterDefinitions() {
            fetch('https://raw.githubusercontent.com/deskull-m/bakabakaband/refs/heads/master/lib/edit/MonraceDefinitions.jsonc')
                .then(response => response.text())
                .then(text => {
                    // JSONCのコメントを除去
                    const jsonText = text.replace(/\/\*[\s\S]*?\*\//g, '').replace(/\/\/.*$/gm, '');
                    const data = JSON.parse(jsonText);

                    // データ構造を確認してmonsterDefinitionsを設定
                    if (data.monsters) {
                        monsterDefinitions = data.monsters;
                    } else if (Array.isArray(data)) {
                        monsterDefinitions = data;
                    } else {
                        monsterDefinitions = [];
                    }

                    console.log('モンスター定義データを読み込みました:', monsterDefinitions.length, '件');
                    console.log('サンプルモンスター:', monsterDefinitions[0]); // デバッグ用
                })
                .catch(error => {
                    console.error('モンスター定義データの読み込みに失敗しました:', error);
                    // エラーでも地形定義は使用可能にする
                    monsterDefinitions = [];
                });
        }

        // 新規地形定義ダイアログのHTML更新
        function updateSymbolDialog() {
            // 地形セレクトボックスを初期化
            populateActualTerrain();
            populateVisualTerrain();

            // モンスターセレクトボックスを更新
            populateMonsterSelect();

            // イベントリスナーを追加（既存のリスナーをクリア）
            const actualSelect = document.getElementById('actualTerrain');
            const visualSelect = document.getElementById('visualTerrain');

            actualSelect.removeEventListener('change', onActualTerrainChange);
            visualSelect.removeEventListener('change', onVisualTerrainChange);

            actualSelect.addEventListener('change', onActualTerrainChange);
            visualSelect.addEventListener('change', onVisualTerrainChange);
        }

        // 実際の地形セレクトボックスを更新する関数
        function populateActualTerrain(filterText = '') {
            const actualSelect = document.getElementById('actualTerrain');
            actualSelect.innerHTML = '<option value="">選択してください</option>';

            const filteredTerrains = terrainDefinitions.filter(terrain => {
                if (!filterText) return true;

                const baseName = terrain.japaneName || terrain.englishName || terrain.name || '';
                const tagsText = terrain.tags ? terrain.tags.join(' ') : '';
                const searchText = filterText.toLowerCase();

                return baseName.toLowerCase().includes(searchText) ||
                    tagsText.toLowerCase().includes(searchText) ||
                    terrain.id.toString().includes(searchText);
            });

            filteredTerrains.forEach(terrain => {
                const baseName = terrain.japaneName || terrain.englishName || terrain.name;
                let displayName = `${terrain.id}: ${baseName}`;

                if (terrain.tags && terrain.tags.length > 0) {
                    const tagsText = terrain.tags.join(', ');
                    displayName += ` (${tagsText})`;
                }

                const option = document.createElement('option');
                option.value = terrain.id;
                option.textContent = displayName;
                actualSelect.appendChild(option);
            });

            // 検索結果の件数を表示
            const filterInput = document.getElementById('actualTerrainFilter');
            if (filterText && filterInput) {
                filterInput.placeholder = `${filteredTerrains.length}件見つかりました`;
            } else if (filterInput) {
                filterInput.placeholder = '地形名で検索...';
            }
        }

        // 見た目の地形セレクトボックスを更新する関数
        function populateVisualTerrain(filterText = '') {
            const visualSelect = document.getElementById('visualTerrain');
            visualSelect.innerHTML = '<option value="">選択してください</option>';

            const filteredTerrains = terrainDefinitions.filter(terrain => {
                if (!filterText) return true;

                const baseName = terrain.japaneName || terrain.englishName || terrain.name || '';
                const tagsText = terrain.tags ? terrain.tags.join(' ') : '';
                const searchText = filterText.toLowerCase();

                return baseName.toLowerCase().includes(searchText) ||
                    tagsText.toLowerCase().includes(searchText) ||
                    terrain.id.toString().includes(searchText);
            });

            filteredTerrains.forEach(terrain => {
                const baseName = terrain.japaneName || terrain.englishName || terrain.name;
                let displayName = `${terrain.id}: ${baseName}`;

                if (terrain.tags && terrain.tags.length > 0) {
                    const tagsText = terrain.tags.join(', ');
                    displayName += ` (${tagsText})`;
                }

                const option = document.createElement('option');
                option.value = terrain.id;
                option.textContent = displayName;
                visualSelect.appendChild(option);
            });

            // 検索結果の件数を表示
            const filterInput = document.getElementById('visualTerrainFilter');
            if (filterText && filterInput) {
                filterInput.placeholder = `${filteredTerrains.length}件見つかりました`;
            } else if (filterInput) {
                filterInput.placeholder = '地形名で検索...';
            }
        }

        // 実際の地形フィルター機能
        function filterActualTerrain() {
            const filterText = document.getElementById('actualTerrainFilter').value;
            populateActualTerrain(filterText);
        }

        // 見た目の地形フィルター機能
        function filterVisualTerrain() {
            const filterText = document.getElementById('visualTerrainFilter').value;
            populateVisualTerrain(filterText);
        }

        // 実際の地形フィルターをクリア
        function clearActualTerrainFilter() {
            document.getElementById('actualTerrainFilter').value = '';
            populateActualTerrain();
        }

        // 見た目の地形フィルターをクリア
        function clearVisualTerrainFilter() {
            document.getElementById('visualTerrainFilter').value = '';
            populateVisualTerrain();
        }

        // モンスターセレクトボックスを更新する関数
        function populateMonsterSelect(filterText = '') {
            const monsterSelect = document.getElementById('monsterSelect');
            monsterSelect.innerHTML = '<option value="">なし</option>';

            const filteredMonsters = monsterDefinitions.filter(monster => {
                if (!filterText) return true;

                const jaName = monster.name?.ja || monster.japaneName || '';
                const enName = monster.name?.en || monster.englishName || monster.name || '';
                const searchText = filterText.toLowerCase();

                return jaName.toLowerCase().includes(searchText) ||
                    enName.toLowerCase().includes(searchText) ||
                    monster.id.toString().includes(searchText);
            });

            filteredMonsters.forEach(monster => {
                const option = document.createElement('option');
                option.value = monster.id;

                // モンスター表示形式: ID: symbol Lv## 日本語名 / 英語名
                let displayName = '';
                if (monster.id !== undefined) {
                    displayName = `${monster.id}: `;

                    if (monster.symbol && monster.symbol.character) {
                        displayName += `${monster.symbol.character} `;
                    }

                    if (monster.level !== undefined) {
                        displayName += `Lv${monster.level} `;
                    }

                    // 日本語名と英語名を並列表示
                    const jaName = monster.name?.ja || monster.japaneName || '';
                    const enName = monster.name?.en || monster.englishName || monster.name || '';

                    if (jaName && enName && jaName !== enName) {
                        displayName += `${jaName.substring(0, 30)} / ${enName.substring(0, 30)}`;
                    } else if (jaName) {
                        displayName += jaName.substring(0, 30);
                    } else if (enName) {
                        displayName += enName.substring(0, 30);
                    } else {
                        displayName += 'Unknown Monster';
                    }
                } else {
                    displayName = 'Invalid Monster Data';
                }

                option.textContent = displayName;
                monsterSelect.appendChild(option);
            });

            // 検索結果の件数を表示
            const filterInput = document.getElementById('monsterFilter');
            if (filterText && filterInput) {
                filterInput.placeholder = `${filteredMonsters.length}件見つかりました`;
            } else if (filterInput) {
                filterInput.placeholder = 'モンスター名で検索...';
            }
        }

        // モンスターフィルター機能
        function filterMonsters() {
            const filterText = document.getElementById('monsterFilter').value;
            populateMonsterSelect(filterText);
        }

        // モンスターフィルターをクリア
        function clearMonsterFilter() {
            document.getElementById('monsterFilter').value = '';
            populateMonsterSelect();
        }

        // 実際の地形セレクトボックスの変更イベント
        function onActualTerrainChange() {
            const actualSelect = document.getElementById('actualTerrain');
            const visualSelect = document.getElementById('visualTerrain');

            // 見た目の地形が未選択の場合、同じ値に設定
            if (actualSelect.value && !visualSelect.value) {
                visualSelect.value = actualSelect.value;
            }
        }

        // 見た目の地形セレクトボックスの変更イベント
        function onVisualTerrainChange() {
            const actualSelect = document.getElementById('actualTerrain');
            const visualSelect = document.getElementById('visualTerrain');

            // 実際の地形が未選択の場合、同じ値に設定
            if (visualSelect.value && !actualSelect.value) {
                actualSelect.value = visualSelect.value;
            }
        }

        function defineCustomTerrain() {
            const symbol = document.getElementById('symbolInput').value;
            const actualTerrain = document.getElementById('actualTerrain').value;
            const visualTerrain = document.getElementById('visualTerrain').value;
            const monsterId = document.getElementById('monsterSelect').value;

            if (!symbol || symbol.length !== 1) {
                alert('1文字のシンボルを入力してください');
                return;
            }

            if (!actualTerrain) {
                alert('実際の地形を選択してください');
                return;
            }

            if (!visualTerrain) {
                alert('見た目の地形を選択してください');
                return;
            }

            // 状態を保存
            saveState();

            // カスタム地形を保存
            customTerrains[symbol] = {
                actual: actualTerrain,
                visual: visualTerrain,
                monster: monsterId || null
            };

            // 現在の地形として設定
            currentTerrain = symbol;

            // メインの地形選択セレクトボックスに追加
            addSymbolToMainSelect(symbol);

            // フォームをクリア
            document.getElementById('symbolInput').value = '';
            document.getElementById('actualTerrain').value = '';
            document.getElementById('visualTerrain').value = '';
            document.getElementById('monsterSelect').value = '';

            closeDialog();

            // Bootstrapトーストで成功メッセージを表示
            showToast(`新規地形 "${symbol}" が定義されました`, 'success');
        }

        function addSymbolToMainSelect(symbol) {
            const selectBox = document.getElementById('grid_type');
            const option = document.createElement('option');
            option.value = symbol;

            // 実際の地形と見た目の地形の情報を表示
            const terrainData = customTerrains[symbol];
            const actualTerrainInfo = terrainDefinitions.find(t => t.id == terrainData.actual);
            const visualTerrainInfo = terrainDefinitions.find(t => t.id == terrainData.visual);

            const actualName = actualTerrainInfo ? (actualTerrainInfo.japaneName || actualTerrainInfo.englishName || actualTerrainInfo.name) : 'Unknown';
            const visualName = visualTerrainInfo ? (visualTerrainInfo.japaneName || visualTerrainInfo.englishName || visualTerrainInfo.name) : 'Unknown';

            let description = `${actualName}(${actualTerrainInfo.tags.join(', ')}) 見た目: ${visualName}(${visualTerrainInfo.tags.join(', ')})`;

            if (terrainData.monster) {
                const monsterInfo = monsterDefinitions.find(m => m.id == terrainData.monster);
                let monsterName = 'Unknown Monster';

                if (monsterInfo) {
                    // モンスター名を適切に取得
                    const jaName = monsterInfo.name?.ja || monsterInfo.japaneName || '';
                    const enName = monsterInfo.name?.en || monsterInfo.englishName || monsterInfo.name || '';

                    if (jaName && enName && jaName !== enName) {
                        monsterName = `${jaName} / ${enName}`;
                    } else if (jaName) {
                        monsterName = jaName;
                    } else if (enName) {
                        monsterName = enName;
                    }
                }

                description += `, モンスター: ${monsterName}`;
            }

            description += ')';

            option.textContent = `${symbol} - ${description}`;
            selectBox.appendChild(option);

            // 新しく追加した地形を選択状態にする
            selectBox.value = symbol;
        }
        // Bootstrapトーストを表示する関数
        function showToast(message, type = 'info') {
            // トーストコンテナがなければ作成
            let toastContainer = document.getElementById('toast-container');
            if (!toastContainer) {
                toastContainer = document.createElement('div');
                toastContainer.id = 'toast-container';
                toastContainer.className = 'toast-container position-fixed top-50 start-50 translate-middle';
                toastContainer.style.zIndex = '9999';
                document.body.appendChild(toastContainer);
            }

            // トーストHTMLを作成
            const toastId = 'toast-' + Date.now();
            const toastHtml = `
                <div id="${toastId}" class="toast" role="alert" aria-live="assertive" aria-atomic="true" style="opacity: 0; transition: opacity 0.3s ease-in-out;">
                    <div class="toast-header">
                        <span class="badge bg-${type === 'success' ? 'success' : 'info'} me-2"></span>
                        <strong class="me-auto">地形エディタ</strong>
                        <small>今</small>
                        <button type="button" class="btn-close" data-bs-dismiss="toast" aria-label="Close"></button>
                    </div>
                    <div class="toast-body">
                        ${message}
                    </div>
                </div>
            `;

            // トーストを追加
            toastContainer.insertAdjacentHTML('beforeend', toastHtml);

            // Bootstrapトーストを初期化
            const toastElement = document.getElementById(toastId);
            const toast = new bootstrap.Toast(toastElement, {
                autohide: true,
                delay: 3000
            });

            // フェードイン効果
            setTimeout(() => {
                toastElement.style.opacity = '1';
            }, 100);

            // トーストを表示
            toast.show();

            // 2.5秒後にフェードアウト開始
            setTimeout(() => {
                toastElement.style.opacity = '0';
            }, 2500);

            // トーストが非表示になったら要素を削除
            toastElement.addEventListener('hidden.bs.toast', function () {
                toastElement.remove();
            });

            // フェードアウト完了後に強制的に削除（念のため）
            setTimeout(() => {
                if (toastElement.parentNode) {
                    toastElement.remove();
                }
            }, 3300);
        }

        function parseTextToGUI() {
            const text = document.getElementById('v_info').value;
            const lines = text.split(/\r?\n/);
            let error = null;
            try {
                const nMatch = lines[0].match(/^N:(\d+):(.*)$/);
                if (!nMatch) throw "N:ブロックの定義が不正です";
                document.getElementById('vault-id').value = nMatch[1];
                document.getElementById('vault-name').value = nMatch[2];

                const xMatch = lines[1].match(/^X:(\d+):(\d+):(\d+):(\d+)$/);
                if (!xMatch) throw "X:ブロックの定義が不正です";
                document.getElementById('vault-type').value = xMatch[1];
                document.getElementById('vault-height').value = xMatch[3];
                document.getElementById('vault-width').value = xMatch[4];

                // F:行を解析
                customTerrains = {};
                let dataLineStart = 2;
                for (let i = 2; i < lines.length; i++) {
                    const line = lines[i];
                    if (line.startsWith('F:')) {
                        const fMatch = line.match(/^F:(\w):(\d+):(\d+)$/);
                        if (fMatch) {
                            // F:行から地形定義を復元（シンボルは後で判定）
                            dataLineStart = i + 1;
                        } else {
                            throw `F:ブロック${i}行目が不正です`;
                        }
                    } else if (line.startsWith('D:')) {
                        dataLineStart = i;
                        break;
                    }
                }

                // グリッドデータを解析
                let gridData = [];
                for (let j = 0; j < parseInt(xMatch[3]); j++) {
                    const dLine = lines[dataLineStart + j];
                    if (!dLine || !dLine.startsWith('D:')) throw `D:ブロック${j}行目が不正です`;
                    const row = dLine.slice(2);
                    if (row.length !== parseInt(xMatch[4])) throw `D:ブロック${j}行目の長さが幅と一致しません`;
                    gridData.push(row.split(''));
                }

                for (let i = 0; i < gridData[0].length; i++) {
                    for (let j = 0; j < gridData.length; j++) {
                        grid[i][j] = gridData[j][i];
                    }
                }

                mapID = nMatch[1];
                mapName = nMatch[2];
                mapType = xMatch[1];
                mapHeight = parseInt(xMatch[3]);
                mapWidth = parseInt(xMatch[4]);
                drawGrid();
            } catch (e) {
                error = e;
            }
            showParseError(error);
        }

        function showParseError(msg) {
            let errDiv = document.getElementById('parse-error');
            if (!errDiv) {
                errDiv = document.createElement('div');
                errDiv.id = 'parse-error';
                errDiv.style.color = 'red';
                document.getElementById('texts').appendChild(errDiv);
            }
            errDiv.textContent = msg ? `構文エラー: ${msg}` : '';
            errDiv.style.display = msg ? 'block' : 'none';
        }

        document.getElementById('v_info').addEventListener('input', parseTextToGUI);

        // キーボードショートカットの追加
        document.addEventListener('keydown', function (e) {
            // Ctrl+Z または Cmd+Z でアンドゥ
            if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
                e.preventDefault();
                undo();
            }
            // Ctrl+Y または Ctrl+Shift+Z または Cmd+Y または Cmd+Shift+Z でリドゥ
            else if (((e.ctrlKey || e.metaKey) && e.key === 'y') ||
                ((e.ctrlKey || e.metaKey) && e.shiftKey && e.key === 'Z')) {
                e.preventDefault();
                redo();
            }
            // Fキーでフラッドフィルモード切り替え
            else if (e.key === 'f' || e.key === 'F') {
                e.preventDefault();
                const floodFillMode = document.getElementById('floodFillMode');
                floodFillMode.checked = true;
                setDrawingMode();
            }
            // Dキーで通常描画モード切り替え
            else if (e.key === 'd' || e.key === 'D') {
                e.preventDefault();
                const normalMode = document.getElementById('normalMode');
                normalMode.checked = true;
                setDrawingMode();
            }
            // Rキーで矩形描画モード切り替え
            else if ((e.key === 'r' || e.key === 'R') && !e.shiftKey) {
                e.preventDefault();
                const rectangleMode = document.getElementById('rectangleMode');
                rectangleMode.checked = true;
                setDrawingMode();
            }
            // Shift+Rで塗りつぶし矩形モード切り替え
            else if ((e.key === 'r' || e.key === 'R') && e.shiftKey) {
                e.preventDefault();
                const filledRectangleMode = document.getElementById('filledRectangleMode');
                filledRectangleMode.checked = true;
                setDrawingMode();
            }
            // Cキーで円形描画モード切り替え
            else if ((e.key === 'c' || e.key === 'C') && !e.shiftKey) {
                e.preventDefault();
                const circleMode = document.getElementById('circleMode');
                circleMode.checked = true;
                setDrawingMode();
            }
            // Shift+Cで塗りつぶし円形モード切り替え
            else if ((e.key === 'c' || e.key === 'C') && e.shiftKey) {
                e.preventDefault();
                const filledCircleMode = document.getElementById('filledCircleMode');
                filledCircleMode.checked = true;
                setDrawingMode();
            }
        });

        // 初期状態を保存（ページ読み込み完了後）
        window.addEventListener('load', function () {
            // 少し遅延させて初期状態を保存
            setTimeout(saveState, 100);
        });

    </script>
</body>

<script type="text/babel">
    const VERSION = "0.0.2";
    function App() {
        return (
            <div>
                <pre>*band Vault Editor by Deskull. Ver.{VERSION}</pre>
            </div>
        );
    }

    function SlideUp() {
        saveState();
        for (let i = 0; i < mapWidth; i++) {
            for (let j = 0; j < mapHeight - 1; j++) {
                grid[i][j] = grid[i][j + 1];
            }
        }
        drawGrid();
        update_texts();
    }

    function SlideLeft() {
        saveState();
        for (let i = 0; i < mapWidth - 1; i++) {
            for (let j = 0; j < mapHeight; j++) {
                grid[i][j] = grid[i + 1][j];
            }
        }
        drawGrid();
        update_texts();
    }

    function SlideRight() {
        saveState();
        for (let i = mapWidth - 1; i > 0; i--) {
            for (let j = 0; j < mapHeight; j++) {
                grid[i][j] = grid[i - 1][j];
            }
        }
        drawGrid();
        update_texts();
    }

    function SlideDown() {
        saveState();
        for (let i = 0; i < mapWidth; i++) {
            for (let j = mapHeight - 1; j > 0; j--) {
                grid[i][j] = grid[i][j - 1];
            }
        }
        drawGrid();
        update_texts();
    }

    function SlideKeys() {
        return (
            <div className="d-flex flex-wrap gap-1">
                {/* スライド操作 */}
                <div className="btn-group" role="group" aria-label="スライド操作">
                    <button className="btn btn-dark btn-sm" onClick={SlideUp} title="上にスライド">
                        <i className="bi bi-arrow-up text-primary"></i>
                    </button>
                    <button className="btn btn-dark btn-sm" onClick={SlideDown} title="下にスライド">
                        <i className="bi bi-arrow-down text-primary"></i>
                    </button>
                    <button className="btn btn-dark btn-sm" onClick={SlideLeft} title="左にスライド">
                        <i className="bi bi-arrow-left text-primary"></i>
                    </button>
                    <button className="btn btn-dark btn-sm" onClick={SlideRight} title="右にスライド">
                        <i className="bi bi-arrow-right text-primary"></i>
                    </button>
                </div>

                {/* 回転操作 */}
                <div className="btn-group" role="group" aria-label="回転操作">
                    <button className="btn btn-dark btn-sm" onClick={RotateLeft} title="左回転">
                        <i className="bi bi-arrow-counterclockwise text-success"></i>
                    </button>
                    <button className="btn btn-dark btn-sm" onClick={RotateRight} title="右回転">
                        <i className="bi bi-arrow-clockwise text-success"></i>
                    </button>
                </div>

                {/* 反転操作 */}
                <div className="btn-group" role="group" aria-label="反転操作">
                    <button className="btn btn-dark btn-sm" onClick={ReverseGridLeftRight} title="左右反転">
                        <i className="bi bi-arrow-left-right text-warning"></i>
                    </button>
                    <button className="btn btn-dark btn-sm" onClick={ReverseGridUpDown} title="上下反転">
                        <i className="bi bi-arrow-down-up text-warning"></i>
                    </button>
                </div>

                {/* 外周コーティング */}
                <button className="btn btn-dark btn-sm" onClick={CoatingOutsideVault} title="外周に%を配置">
                    <i className="bi bi-percent text-info"></i>
                </button>

                {/* ミラー操作 */}
                <div className="btn-group" role="group" aria-label="ミラー操作">
                    <button className="btn btn-dark btn-sm" onClick={MirrorGridLeftToRight} title="左から右へミラー">
                        <i className="bi bi-chevron-double-right text-light"></i>
                    </button>
                    <button className="btn btn-dark btn-sm" onClick={MirrorGridTopToBottom} title="上から下へミラー">
                        <i className="bi bi-chevron-double-down text-light"></i>
                    </button>
                    <button className="btn btn-dark btn-sm" onClick={MirrorGridDiagonal} title="対角線ミラー">
                        <i className="bi bi-slash-lg text-light"></i>
                    </button>
                </div>
            </div>
        );
    }

    function CoatingOutsideVault() {
        saveState();
        for (let i = 0; i < mapWidth; i++) {
            for (let j = 0; j < mapHeight; j++) {
                if (grid[i][j] !== " ") {
                    continue
                }

                if (i > 0 && grid[i - 1][j] !== " " && grid[i - 1][j] !== "%") {
                    grid[i][j] = "%";
                    continue;
                }

                if (j > 0 && grid[i][j - 1] !== " " && grid[i][j - 1] !== "%") {
                    grid[i][j] = "%";
                    continue;
                }

                if (j < mapHeight - 1 && grid[i][j + 1] !== " " && grid[i][j + 1] !== "%") {
                    grid[i][j] = "%";
                    continue;
                }

                if (i < mapWidth - 1 && grid[i + 1][j] !== " " && grid[i + 1][j] !== "%") {
                    grid[i][j] = "%";
                    continue;
                }
            }
        }
        drawGrid();
        update_texts();
    }

    function RotateLeft() {
        saveState();
        let newGrid = Array.from({ length: mapHeight }, () => Array(mapWidth).fill(" "));
        for (let i = 0; i < mapWidth; i++) {
            for (let j = 0; j < mapHeight; j++) {
                newGrid[j][mapWidth - i - 1] = grid[i][j];
            }
        }
        grid = newGrid;
        let tmp = mapWidth;
        mapWidth = mapHeight;
        mapHeight = tmp;
        drawGrid();
        update_texts();
    }

    function RotateRight() {
        saveState();
        let newGrid = Array.from({ length: mapHeight }, () => Array(mapWidth).fill(" "));
        for (let i = 0; i < mapWidth; i++) {
            for (let j = 0; j < mapHeight; j++) {
                newGrid[mapHeight - j - 1][i] = grid[i][j];
            }
        }
        grid = newGrid;
        let tmp = mapWidth;
        mapWidth = mapHeight;
        mapHeight = tmp;
        drawGrid();
        update_texts();
    }

    function ReverseGridLeftRight() {
        saveState();
        let newGrid = Array.from({ length: mapWidth }, () => Array(mapHeight).fill(" "));
        for (let i = 0; i < mapWidth; i++) {
            for (let j = 0; j < mapHeight; j++) {
                newGrid[i][j] = grid[mapWidth - i - 1][j];
            }
        }
        grid = newGrid;
        drawGrid();
        update_texts();
    }

    function ReverseGridUpDown() {
        saveState();
        let newGrid = Array.from({ length: mapWidth }, () => Array(mapHeight).fill(" "));
        for (let i = 0; i < mapWidth; i++) {
            for (let j = 0; j < mapHeight; j++) {
                newGrid[i][j] = grid[i][mapHeight - j - 1];
            }
        }
        grid = newGrid;
        drawGrid();
        update_texts();
    }

    function MirrorGridLeftToRight() {
        saveState();
        for (let j = 0; j < mapHeight; j++) {
            for (let i = 0; i < Math.floor(mapWidth / 2); i++) {
                grid[mapWidth - 1 - i][j] = grid[i][j];
            }
        }
        drawGrid();
        update_texts();
    }

    function MirrorGridTopToBottom() {
        saveState();
        for (let i = 0; i < mapWidth; i++) {
            for (let j = 0; j < Math.floor(mapHeight / 2); j++) {
                grid[i][mapHeight - 1 - j] = grid[i][j];
            }
        }
        drawGrid();
        update_texts();
    }

    // 左下から右上への対角線でミラー
    function MirrorGridDiagonal() {
        saveState();
        for (let i = 0; i < Math.min(mapWidth, mapHeight); i++) {
            for (let j = i + 1; j < Math.min(mapWidth, mapHeight); j++) {
                grid[j][i] = grid[i][j];
            }
        }
        drawGrid();
        update_texts();
    }

    // Rendering the App component to the DOM
    ReactDOM.createRoot(document.getElementById('version')).render(<App />);
    ReactDOM.createRoot(document.getElementById('slide_keys')).render(<SlideKeys />);
</script>

</html>